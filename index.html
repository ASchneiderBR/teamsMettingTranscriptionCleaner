<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Limpador VTT/DOCX &rarr; TXT + M&eacute;tricas</title>
  <style>
    :root{
      color-scheme: light dark;
      --bg:#ffffff; --fg:#0b0f14; --muted: rgba(15, 23, 42, 0.72);
      --card: rgba(2, 6, 23, 0.04); --border: rgba(2, 6, 23, 0.16); --border2: rgba(2, 6, 23, 0.24);
      --btn: rgba(2, 6, 23, 0.06); --btnBorder: rgba(2, 6, 23, 0.18);
      --primary: rgba(37, 99, 235, 0.18); --primaryBorder: rgba(37, 99, 235, 0.45);
      --shadow: 0 8px 24px rgba(2, 6, 23, 0.08);
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --r: 16px;
    }
    @media (prefers-color-scheme: dark){
      :root{
        --bg:#0b0f14; --fg:#e5e7eb; --muted: rgba(229, 231, 235, 0.74);
        --card: rgba(255,255,255,0.06); --border: rgba(255,255,255,0.14); --border2: rgba(255,255,255,0.22);
        --btn: rgba(255,255,255,0.06); --btnBorder: rgba(255,255,255,0.16);
        --primary: rgba(96, 165, 250, 0.18); --primaryBorder: rgba(96, 165, 250, 0.45);
        --shadow: 0 10px 28px rgba(0,0,0,0.35);
      }
    }
    *{box-sizing:border-box}
    body{margin:0; padding:22px; font-family: var(--sans); line-height:1.35; background: var(--bg); color: var(--fg)}
    .wrap{max-width: 900px; margin:0 auto}

    .top{display:flex; flex-wrap:wrap; gap:10px 14px; align-items:baseline; justify-content:space-between; margin-bottom:12px}
    h1{font-size:18px; margin:0; letter-spacing:0.2px}
    .sub{margin:0; font-size:13px; color:var(--muted)}

    .pill{display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid var(--border); background: rgba(127,127,127,0.06); font-size:12px; color: var(--muted); white-space:nowrap}
    .kbd{font-family: var(--mono); border:1px solid var(--border2); border-bottom-width:2px; padding:1px 6px; border-radius:9px; font-size:12px; opacity:0.95}

    .stack{display:flex; flex-direction:column; gap:14px; margin-top:14px}

    .card{border:1px solid var(--border); border-radius: var(--r); padding:14px; background: var(--card); box-shadow: var(--shadow)}
    .card h2{font-size:14px; margin:0 0 10px; opacity:0.95}

    .row{display:grid; grid-template-columns: 1fr; gap:10px}
    @media (min-width: 720px){
      .row.cols2{grid-template-columns: 1fr 1fr}
      .row.cols3{grid-template-columns: 1fr 1fr 1fr}
    }

    label{display:block; font-weight:800; font-size:12px; margin:0 0 6px; opacity:0.92}
    input[type=file], input[type=text]{
      width:100%; padding:10px 12px; border-radius:14px; border:1px solid var(--border2);
      background: transparent; color: var(--fg); outline:none;
    }

    textarea{
      width:100%; min-height:240px; padding:12px; border-radius:14px; border:1px solid var(--border2);
      background: transparent; color: var(--fg); outline:none;
      font-family: var(--mono); font-size:12.5px; resize: vertical;
    }

    .controls{display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-top:10px}
    button{border:1px solid var(--btnBorder); background: var(--btn); color: var(--fg); padding:10px 12px; border-radius:14px; cursor:pointer; font-weight:800}
    button.primary{background: var(--primary); border-color: var(--primaryBorder)}
    button:active{transform: translateY(1px)}
    .status{margin-left:auto; font-size:12px; color: var(--muted)}
    .hint{font-size:12px; color: var(--muted); margin-top:8px}

    table{width:100%; border-collapse:separate; border-spacing:0; overflow:hidden; border-radius:14px; border:1px solid var(--border); margin-top:10px}
    th, td{padding:10px; border-bottom:1px solid var(--border); font-size:12.5px; text-align:left; vertical-align:top}
    th{font-size:12px; color: var(--muted); font-weight:900}
    tr:last-child td{border-bottom:none}

    .bar{height:10px; border-radius:999px; border:1px solid var(--border); background: rgba(127,127,127,0.08); overflow:hidden}
    .bar > div{height:100%; background: var(--primaryBorder); width:0%}

    .chartWrap{margin-top:14px}
    .chartHeader{display:flex; justify-content:space-between; align-items:center; gap:8px}
    .chartTitle{font-size:13px; font-weight:900}
    .chartMeta{font-size:12px; color: var(--muted)}
    .chartGrid{
      height:220px; display:flex; align-items:stretch; gap:2px; padding:8px 6px;
      border:1px solid var(--border); border-radius:14px;
      background: linear-gradient(to top, rgba(127,127,127,0.12) 1px, transparent 1px);
      background-size: 100% 25%;
    }
    .chartBar{flex:1 1 0; display:flex; flex-direction:column-reverse; min-width:2px; height:100%}
    .chartSeg{width:100%; min-height:1px}
    .chartAxis{display:flex; justify-content:space-between; font-size:12px; color: var(--muted); margin-top:6px}
    .legend{display:flex; flex-wrap:wrap; gap:8px 12px; margin-top:8px}
    .legendItem{display:flex; align-items:center; gap:6px; font-size:12px; color: var(--muted)}
    .legendSwatch{width:12px; height:12px; border-radius:3px; border:1px solid var(--border)}
    .chartEmpty{display:flex; align-items:center; justify-content:center; font-size:12px; color: var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div>
        <h1>Limpador de transcri&ccedil;&atilde;o (.vtt/.docx) &rarr; TXT + m&eacute;tricas de fala</h1>
        <p class="sub">Gera linhas <span class="kbd">Nome&gt;Texto</span> e calcula tempo por participante. Para DOCX, o tempo &eacute; estimado.</p>
        <p class="sub">Primeira vez? Carregue um .vtt ou .docx (ou cole VTT) e clique em Processar.</p>
      </div>
      <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
        <span class="pill" id="pillTitle">T&iacute;tulo: &mdash;</span>
        <span class="pill" id="pillTotal">Dura&ccedil;&atilde;o total: &mdash;</span>
        <span class="pill" id="pillPeople">Participantes: &mdash;</span>
      </div>
    </div>

    <div class="stack">
      <div class="card">
        <div class="row cols3">
          <div>
            <label for="file">Arquivo .vtt ou .docx</label>
            <input id="file" type="file" accept=".vtt,.docx,text/vtt,text/plain,application/vnd.openxmlformats-officedocument.wordprocessingml.document" />
            <div class="hint">O t&iacute;tulo tenta ser extra&iacute;do do nome do arquivo automaticamente.</div>
          </div>
          <div>
            <label for="meetingDate">Dia da reuni&atilde;o (dd/mm/aa)</label>
            <input id="meetingDate" type="text" inputmode="numeric" placeholder="dd/mm/aa" />
          </div>
          <div>
            <label for="meetingStart">Hor&aacute;rio de in&iacute;cio (24h)</label>
            <input id="meetingStart" type="text" inputmode="numeric" placeholder="hh:mm" />
          </div>
        </div>
        <div class="row cols2" style="margin-top:10px;">
          <div>
            <label for="meetingTitle">T&iacute;tulo da reuni&atilde;o (opcional)</label>
            <input id="meetingTitle" type="text" placeholder="(se vazio, usa o nome do arquivo)" />
          </div>
          <div>
            <label for="meetingNotes">Observa&ccedil;&otilde;es (opcional)</label>
            <input id="meetingNotes" type="text" placeholder="ex: Alinhamento comercial" />
          </div>
        </div>
      </div>

      <div class="card">
        <h2>Entrada</h2>
        <label for="input">Cole aqui o conte&uacute;do do VTT (ou carregue .vtt/.docx acima)</label>
        <textarea id="input" placeholder="Cole aqui o conte&uacute;do do .vtt..."></textarea>
        <div class="controls">
          <button class="primary" id="process">Processar</button>
          <button id="clear">Limpar</button>
          <span class="status" id="status">Pronto.</span>
        </div>
        <div class="hint" style="margin-top:10px;">
          A limpeza aplica: unir quebras internas, normalizar espa&ccedil;os, remover tags e descartar linhas vazias. Para DOCX, o tempo &eacute; estimado.
        </div>
      </div>

      <div class="card">
        <h2>Sa&iacute;da (TXT limpo)</h2>
        <label for="output">Resumo + tabela (texto puro) + transcri&ccedil;&atilde;o</label>
        <textarea id="output" readonly placeholder="O resultado aparecer&aacute; aqui..."></textarea>
        <div class="controls">
          <button class="primary" id="copy">Copiar</button>
          <button id="download">Baixar .txt</button>
          <span class="status" id="outStatus">&mdash;</span>
        </div>
      </div>

      <div class="card">
        <h2>M&eacute;tricas</h2>
        <div class="row cols2">
          <div><div class="pill" id="metaWhen">Data/hora: &mdash;</div></div>
          <div><div class="pill" id="metaEnd">T&eacute;rmino estimado: &mdash;</div></div>
        </div>

        <table aria-label="Tabela de m&eacute;tricas">
          <thead>
            <tr>
              <th style="width:34%;">Participante</th>
              <th style="width:16%;">Tempo</th>
              <th style="width:14%;">% fala</th>
              <th>Distribui&ccedil;&atilde;o</th>
            </tr>
          </thead>
          <tbody id="statsBody">
            <tr><td colspan="4" style="color: var(--muted);">Nenhum dado ainda.</td></tr>
          </tbody>
        </table>

        <div class="chartWrap">
          <div class="chartHeader">
            <div class="chartTitle">Fala ao longo do tempo</div>
            <div class="chartMeta" id="timelineMeta">&mdash;</div>
          </div>
          <div class="chartGrid chartEmpty" id="timelineChart" role="img" aria-label="Fala ao longo do tempo">
            Sem dados suficientes para o gr&aacute;fico.
          </div>
          <div class="chartAxis">
            <span id="timelineStart">In&iacute;cio</span>
            <span id="timelineEnd">Fim</span>
          </div>
          <div class="legend" id="timelineLegend"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    const fileEl = $("file");
    const inputEl = $("input");
    const outputEl = $("output");
    const statusEl = $("status");
    const outStatusEl = $("outStatus");

    const meetingDateEl = $("meetingDate");
    const meetingStartEl = $("meetingStart");
    const meetingTitleEl = $("meetingTitle");
    const meetingNotesEl = $("meetingNotes");

    const pillTitle = $("pillTitle");
    const pillTotal = $("pillTotal");
    const pillPeople = $("pillPeople");

    const metaWhen = $("metaWhen");
    const metaEnd = $("metaEnd");

    const statsBody = $("statsBody");
    const timelineChart = $("timelineChart");
    const timelineLegend = $("timelineLegend");
    const timelineMeta = $("timelineMeta");
    const timelineStart = $("timelineStart");
    const timelineEnd = $("timelineEnd");

    function setStatus(msg) { statusEl.textContent = msg; }
    function setOutStatus(msg) { outStatusEl.textContent = msg; }
    function logDebug(...args) { console.log("[debug]", ...args); }

    const DEFAULT_SECONDS_PER_CHAR = 0.06;
    const MIN_ESTIMATED_SECONDS = 0.6;
    const WORD_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";

    function isTimestampLine(line) {
      return /\d{2}:\d{2}:\d{2}(?:\.\d+)?\s*-->\s*\d{2}:\d{2}:\d{2}(?:\.\d+)?/.test(line);
    }

    function stripAllTags(s) {
      return s.replace(/<[^>]+>/g, "");
    }

    function normalizeSpaces(s) {
      return s.replace(/\u00A0/g, " ").replace(/\s+/g, " ").trim();
    }

    function parseTimeToSeconds(ts) {
      const m = ts.match(/^(\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?$/);
      if (!m) return null;
      const hh = Number(m[1]);
      const mm = Number(m[2]);
      const ss = Number(m[3]);
      const ms = m[4] ? Number((m[4] + "000").slice(0, 3)) : 0;
      return (hh * 3600) + (mm * 60) + ss + (ms / 1000);
    }

    function formatDuration(seconds) {
      if (!Number.isFinite(seconds) || seconds < 0) return "\u2014";
      const total = Math.round(seconds);
      const hh = Math.floor(total / 3600);
      const mm = Math.floor((total % 3600) / 60);
      const ss = total % 60;
      const pad2 = (n) => String(n).padStart(2, "0");
      return hh > 0 ? `${hh}:${pad2(mm)}:${pad2(ss)}` : `${mm}:${pad2(ss)}`;
    }

    function countSpeechChars(text) {
      return String(text || "").replace(/\s+/g, "").length;
    }

    const speakerColors = [
      "#2563eb",
      "#f97316",
      "#16a34a",
      "#9333ea",
      "#e11d48",
      "#0ea5e9",
      "#f59e0b",
      "#14b8a6",
      "#84cc16",
      "#db2777",
    ];

    function pickBucketSeconds(totalSeconds) {
      if (totalSeconds <= 300) return 15;
      if (totalSeconds <= 1200) return 30;
      if (totalSeconds <= 3600) return 60;
      if (totalSeconds <= 7200) return 120;
      return 300;
    }

    function formatBucketLabel(seconds) {
      if (seconds % 60 === 0) {
        const mins = seconds / 60;
        return `${mins} min`;
      }
      return `${seconds}s`;
    }

    function computeTimeline(cues, orderDesc, bucketSeconds) {
      let minS = Infinity;
      let maxE = -Infinity;
      for (const cue of cues) {
        if (!Number.isFinite(cue.startS) || !Number.isFinite(cue.endS)) continue;
        minS = Math.min(minS, cue.startS);
        maxE = Math.max(maxE, cue.endS);
      }
      if (minS === Infinity || maxE === -Infinity) return null;

      const total = Math.max(0, maxE - minS);
      const bucketCount = Math.max(1, Math.ceil(total / bucketSeconds));

      const buckets = new Map();
      const order = Array.from(orderDesc || []);

      for (const name of order) {
        buckets.set(name, new Array(bucketCount).fill(0));
      }

      for (const cue of cues) {
        if (!Number.isFinite(cue.startS) || !Number.isFinite(cue.endS)) continue;
        if (cue.endS <= cue.startS) continue;
        const speakers = cue.speakers || [];
        const uniqueNames = Array.from(new Set(speakers.map(s => s.name).filter(Boolean)));
        if (!uniqueNames.length) continue;

        for (const name of uniqueNames) {
          if (!buckets.has(name)) {
            buckets.set(name, new Array(bucketCount).fill(0));
            order.push(name);
          }
        }

        const start = cue.startS;
        const end = cue.endS;
        const firstIdx = Math.max(0, Math.floor((start - minS) / bucketSeconds));
        const lastIdx = Math.min(bucketCount - 1, Math.floor((end - minS) / bucketSeconds));
        const share = 1 / uniqueNames.length;

        for (let idx = firstIdx; idx <= lastIdx; idx++) {
          const bucketStart = minS + idx * bucketSeconds;
          const bucketEnd = bucketStart + bucketSeconds;
          const overlap = Math.max(0, Math.min(end, bucketEnd) - Math.max(start, bucketStart));
          if (overlap <= 0) continue;
          for (const name of uniqueNames) {
            buckets.get(name)[idx] += overlap * share;
          }
        }
      }

      let maxBucketSeconds = 0;
      for (let i = 0; i < bucketCount; i++) {
        let sum = 0;
        for (const name of order) {
          const arr = buckets.get(name);
          sum += arr ? arr[i] : 0;
        }
        if (sum > maxBucketSeconds) maxBucketSeconds = sum;
      }

      return { minS, maxE, bucketCount, bucketSeconds, buckets, order, maxBucketSeconds };
    }

    function inferTitleFromFilename(name) {
      if (!name) return "";
      let base = name.replace(/\.[^.]+$/, "");
      base = base.replace(/[_-]+/g, " ").replace(/\s+/g, " ").trim();
      return base;
    }

    function normalizeDateBr(value) {
      const v = (value || "").trim();
      if (!v) return null;
      const m = v.match(/^(\d{2})\/(\d{2})\/(\d{2}|\d{4})$/);
      if (!m) return null;
      const dd = Number(m[1]);
      const mm = Number(m[2]);
      let yy = Number(m[3]);
      if (yy < 100) yy += 2000;
      if (dd < 1 || dd > 31 || mm < 1 || mm > 12) return null;
      return { dd, mm, yy };
    }

    function normalizeTime24(value) {
      const v = (value || "").trim();
      if (!v) return null;
      const m = v.match(/^([01]\d|2[0-3]):([0-5]\d)$/);
      if (!m) return null;
      return { hh: Number(m[1]), mi: Number(m[2]) };
    }

    function buildMeetingDateTime() {
      const d = normalizeDateBr(meetingDateEl.value);
      const t = normalizeTime24(meetingStartEl.value);
      if (!d || !t) return null;
      const dt = new Date(d.yy, d.mm - 1, d.dd, t.hh, t.mi, 0, 0);
      return isNaN(dt.getTime()) ? null : dt;
    }

    function formatDateInput(value) {
      const digits = String(value || "").replace(/\D/g, "").slice(0, 6);
      if (digits.length <= 2) return digits;
      if (digits.length <= 4) return `${digits.slice(0, 2)}/${digits.slice(2)}`;
      return `${digits.slice(0, 2)}/${digits.slice(2, 4)}/${digits.slice(4)}`;
    }

    function formatTimeInput(value) {
      const digits = String(value || "").replace(/\D/g, "").slice(0, 4);
      if (digits.length <= 2) return digits;
      return `${digits.slice(0, 2)}:${digits.slice(2)}`;
    }

    function formatLocalDateTime(dt) {
      if (!(dt instanceof Date) || isNaN(dt.getTime())) return "\u2014";
      try {
        return new Intl.DateTimeFormat("pt-BR", {
          day: "2-digit",
          month: "2-digit",
          year: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          hourCycle: "h23",
        }).format(dt);
      } catch {
        return dt.toLocaleString("pt-BR");
      }
    }

    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function findZipEocdOffset(view) {
      const min = Math.max(0, view.byteLength - 0x10000 - 22);
      for (let i = view.byteLength - 22; i >= min; i--) {
        if (view.getUint32(i, true) === 0x06054b50) return i;
      }
      return -1;
    }

    async function inflateRaw(data) {
      if (typeof DecompressionStream === "undefined") {
        throw new Error("Seu navegador n\u00e3o suporta descompactar DOCX.");
      }
      const ds = new DecompressionStream("deflate-raw");
      const stream = new Blob([data]).stream().pipeThrough(ds);
      return await new Response(stream).arrayBuffer();
    }

    async function readZipEntry(buffer, entryName) {
      const view = new DataView(buffer);
      const eocdOffset = findZipEocdOffset(view);
      if (eocdOffset < 0) throw new Error("Arquivo DOCX inv\u00e1lido (EOCD).");

      const totalEntries = view.getUint16(eocdOffset + 10, true);
      const cdOffset = view.getUint32(eocdOffset + 16, true);
      const decoder = new TextDecoder("utf-8");

      let ptr = cdOffset;
      let entry = null;
      for (let i = 0; i < totalEntries; i++) {
        if (view.getUint32(ptr, true) !== 0x02014b50) break;
        const compMethod = view.getUint16(ptr + 10, true);
        const compSize = view.getUint32(ptr + 20, true);
        const uncompSize = view.getUint32(ptr + 24, true);
        const nameLen = view.getUint16(ptr + 28, true);
        const extraLen = view.getUint16(ptr + 30, true);
        const commentLen = view.getUint16(ptr + 32, true);
        const localOffset = view.getUint32(ptr + 42, true);
        const nameBytes = new Uint8Array(buffer, ptr + 46, nameLen);
        const name = decoder.decode(nameBytes);
        if (name === entryName) {
          entry = { compMethod, compSize, uncompSize, localOffset };
          break;
        }
        ptr += 46 + nameLen + extraLen + commentLen;
      }

      if (!entry) throw new Error(`Entrada n\u00e3o encontrada no DOCX: ${entryName}`);

      if (view.getUint32(entry.localOffset, true) !== 0x04034b50) {
        throw new Error("Cabe\u00e7alho ZIP inv\u00e1lido.");
      }
      const localNameLen = view.getUint16(entry.localOffset + 26, true);
      const localExtraLen = view.getUint16(entry.localOffset + 28, true);
      const dataStart = entry.localOffset + 30 + localNameLen + localExtraLen;
      const compData = buffer.slice(dataStart, dataStart + entry.compSize);

      if (entry.compMethod === 0) return compData;
      if (entry.compMethod === 8) return await inflateRaw(compData);
      throw new Error(`Compress\u00e3o ZIP n\u00e3o suportada: ${entry.compMethod}`);
    }

    async function extractDocxDocumentXml(buffer) {
      const xmlBuffer = await readZipEntry(buffer, "word/document.xml");
      return new TextDecoder("utf-8").decode(xmlBuffer);
    }

    function extractParagraphLines(paragraph) {
      const lines = [""];
      const addText = (t) => { lines[lines.length - 1] += t; };
      const walk = (node) => {
        if (node.nodeType !== 1) return;
        if (node.namespaceURI && node.namespaceURI !== WORD_NS) return;
        const name = node.localName;
        if (name === "drawing" || name === "pict" || name === "object") return;
        if (name === "br" || name === "cr") {
          lines.push("");
          return;
        }
        if (name === "tab") {
          addText("\t");
          return;
        }
        if (name === "t") {
          addText(node.textContent || "");
          return;
        }
        for (const child of node.childNodes) walk(child);
      };
      walk(paragraph);
      return lines.map(l => normalizeSpaces(l)).filter(Boolean);
    }

    function extractDocxTextLines(docXml) {
      const doc = new DOMParser().parseFromString(docXml, "application/xml");
      if (doc.getElementsByTagName("parsererror").length) return [];
      let paragraphs = Array.from(doc.getElementsByTagNameNS(WORD_NS, "p"));
      if (!paragraphs.length) paragraphs = Array.from(doc.getElementsByTagName("w:p"));
      if (!paragraphs.length) paragraphs = Array.from(doc.getElementsByTagName("p"));
      const lines = [];
      for (const p of paragraphs) {
        const pLines = extractParagraphLines(p);
        if (pLines.length) lines.push(...pLines);
      }
      return lines;
    }

    function parseDocxTimeToSeconds(ts) {
      const parts = String(ts || "").split(":").map(p => Number(p));
      if (parts.some(n => !Number.isFinite(n))) return null;
      if (parts.length === 2) return (parts[0] * 60) + parts[1];
      if (parts.length === 3) return (parts[0] * 3600) + (parts[1] * 60) + parts[2];
      return null;
    }

    function parseDocxLines(lines) {
      const cleaned = (lines || []).map(l => normalizeSpaces(l)).filter(Boolean);
      if (!cleaned.length) return null;
      const joined = cleaned.join(" ");
      if (/come\u00e7ou a transcri/i.test(joined) || /parou a transcri/i.test(joined)) return null;

      const timeOnly = /^\d{1,2}:\d{2}(?::\d{2})?$/;
      let speaker = "";
      let timeStr = "";
      let textParts = [];

      const first = cleaned[0];
      const match = first.match(/^(.*?)[\s]+(\d{1,2}:\d{2}(?::\d{2})?)(?:\s+(.*))?$/);
      if (match) {
        speaker = match[1];
        timeStr = match[2];
        if (match[3]) textParts.push(match[3]);
        textParts = textParts.concat(cleaned.slice(1));
      } else if (cleaned.length >= 2 && timeOnly.test(cleaned[1])) {
        speaker = cleaned[0];
        timeStr = cleaned[1];
        textParts = cleaned.slice(2);
      } else {
        return null;
      }

      speaker = String(speaker).replace(/[:\uFF1A]\s*$/, "").trim();
      const text = normalizeSpaces(textParts.join(" "));
      if (!speaker || !text) return null;
      const startS = parseDocxTimeToSeconds(timeStr);
      if (!Number.isFinite(startS)) return null;

      return { speaker, text, startS, timeStr };
    }

    function parseDocxSegmentsFromLines(lines) {
      const segments = [];
      const timeOnly = /^\d{1,2}:\d{2}(?::\d{2})?$/;
      const isSystemLine = (line) => /come\u00e7ou a transcri/i.test(line) || /parou a transcri/i.test(line);
      let i = 0;

      while (i < lines.length) {
        const maybeSpeaker = lines[i];
        const maybeTime = lines[i + 1];
        let speaker = "";
        let timeStr = "";
        if (maybeSpeaker) {
          const inline = maybeSpeaker.match(/^(.*?)[\s]+(\d{1,2}:\d{2}(?::\d{2})?)$/);
          if (inline) {
            speaker = inline[1];
            timeStr = inline[2];
            i += 1;
          } else if (maybeTime && timeOnly.test(maybeTime)) {
            speaker = maybeSpeaker;
            timeStr = maybeTime;
            i += 2;
          }
        }

        if (speaker && timeStr) {
          speaker = String(speaker).replace(/[:\uFF1A]\s*$/, "").trim();
          const startS = parseDocxTimeToSeconds(timeStr);
          const textParts = [];
          while (i < lines.length) {
            const lookSpeaker = lines[i];
            const lookTime = lines[i + 1];
            if (lookSpeaker && lookTime && timeOnly.test(lookTime)) break;
            if (lookSpeaker && !isSystemLine(lookSpeaker)) textParts.push(lookSpeaker);
            i++;
          }
          const text = normalizeSpaces(textParts.join(" "));
          if (speaker && text && Number.isFinite(startS)) {
            segments.push({ speaker, text, startS, timeStr });
          }
          continue;
        }
        i++;
      }

      return segments;
    }

    function parseDocxSegments(docXml) {
      const doc = new DOMParser().parseFromString(docXml, "application/xml");
      if (doc.getElementsByTagName("parsererror").length) {
        throw new Error("Falha ao interpretar XML do DOCX.");
      }
      let paragraphs = Array.from(doc.getElementsByTagNameNS(WORD_NS, "p"));
      if (!paragraphs.length) paragraphs = Array.from(doc.getElementsByTagName("w:p"));
      if (!paragraphs.length) paragraphs = Array.from(doc.getElementsByTagName("p"));
      logDebug("DOCX par\u00e1grafos encontrados", { count: paragraphs.length });
      const segments = [];

      for (const p of paragraphs) {
        const lines = extractParagraphLines(p);
        if (!lines.length) continue;
        const seg = parseDocxLines(lines);
        if (!seg) continue;
        segments.push(seg);
      }

      if (segments.length) {
        logDebug("DOCX segmentos exemplo", segments.slice(0, 3));
      }

      if (!segments.length) {
        const fallbackLines = extractDocxTextLines(docXml);
        logDebug("DOCX fallback linhas (amostra)", fallbackLines.slice(0, 8));
        const fallbackSegments = parseDocxSegmentsFromLines(fallbackLines);
        if (fallbackSegments.length) {
          logDebug("DOCX fallback parser ativo", { lines: fallbackLines.length, segments: fallbackSegments.length });
          const cleanLines = fallbackSegments.map(s => `${s.speaker}>${s.text}`);
          return { segments: fallbackSegments, cleanText: cleanLines.join("\n") };
        }
      }

      const cleanLines = segments.map(s => `${s.speaker}>${s.text}`);
      return { segments, cleanText: cleanLines.join("\n") };
    }

    function estimateDurationSeconds(text) {
      const chars = countSpeechChars(text);
      return chars * DEFAULT_SECONDS_PER_CHAR;
    }

    function buildDocxCuesFromSegments(segments) {
      const cues = [];
      for (let i = 0; i < segments.length; i++) {
        const seg = segments[i];
        if (!Number.isFinite(seg.startS)) continue;
        const next = segments[i + 1];
        const nextStart = next && Number.isFinite(next.startS) ? next.startS : null;
        const gap = (Number.isFinite(nextStart) && nextStart > seg.startS) ? (nextStart - seg.startS) : null;
        let dur = estimateDurationSeconds(seg.text);
        dur = Math.max(MIN_ESTIMATED_SECONDS, dur || 0);
        if (Number.isFinite(gap) && gap > 0) {
          dur = Math.min(dur, gap);
        }
        const endS = seg.startS + dur;
        cues.push({
          startS: seg.startS,
          endS,
          speakers: [{ name: seg.speaker, text: seg.text }],
        });
      }
      return cues;
    }

    function parseVtt(raw) {
      const joinInternal = true;
      const doTrim = true;
      const removeTags = true;
      const dropEmpty = true;

      const text = (raw || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      const blocks = text.split(/\n\s*\n+/g);

      const cleanLines = [];
      const cues = []; // {startS, endS, speakers: [{name, text}]}

      for (const block of blocks) {
        const lines = block.split("\n").map(l => l.trimEnd());
        if (!lines.length) continue;

        if (lines[0].trim() === "WEBVTT") continue;
        const first = lines[0].trim();
        if (/^(NOTE|STYLE|REGION)\b/i.test(first)) continue;

        let i = 0;
        if (lines[i] && !isTimestampLine(lines[i]) && !/^\d{2}:\d{2}:\d{2}/.test(lines[i]) && !/<v\s+/i.test(lines[i])) {
          i++;
        }

        if (!lines[i] || !isTimestampLine(lines[i])) {
          const payloadFallback = lines.slice(i).filter(l => l.trim().length > 0);
          if (!payloadFallback.length) continue;
          let line = joinInternal ? payloadFallback.join(" ") : payloadFallback.join("\n");
          if (removeTags) line = stripAllTags(line);
          if (doTrim) line = normalizeSpaces(line);
          if (!line && dropEmpty) continue;
          cleanLines.push(line);
          continue;
        }

        const tsLine = lines[i].trim();
        i++;
        const tm = tsLine.match(/(\d{2}:\d{2}:\d{2}(?:\.\d+)?)\s*-->\s*(\d{2}:\d{2}:\d{2}(?:\.\d+)?)/);
        const startS = tm ? parseTimeToSeconds(tm[1]) : null;
        const endS = tm ? parseTimeToSeconds(tm[2]) : null;

        const payload = lines.slice(i).filter(l => l.trim().length > 0);
        if (!payload.length) continue;
        const payloadText = joinInternal ? payload.join(" ") : payload.join("\n");

        const segs = [];
        const re = /<v\s+([^>]+)>([\s\S]*?)<\/v>/gi;
        let match;
        while ((match = re.exec(payloadText)) !== null) {
          const speaker = (match[1] || "").trim();
          let content = match[2] || "";
          if (removeTags) content = stripAllTags(content);
          if (doTrim) content = normalizeSpaces(content);
          if (!content && dropEmpty) continue;
          segs.push({ name: speaker, text: content });
          cleanLines.push(`${speaker}>${content}`);
        }

        if (segs.length) {
          if (Number.isFinite(startS) && Number.isFinite(endS) && endS >= startS) {
            cues.push({ startS, endS, speakers: segs });
          }
          continue;
        }

        // Suporte a <v Nome> sem tag de fechamento (comum em VTT)
        const looseSegs = [];
        const tagRe = /<v\s+([^>]+)>/gi;
        let lastIndex = 0;
        let lastName = null;
        let tag;
        while ((tag = tagRe.exec(payloadText)) !== null) {
          if (lastName !== null) {
            let content = payloadText.slice(lastIndex, tag.index);
            if (removeTags) content = stripAllTags(content);
            if (doTrim) content = normalizeSpaces(content);
            if (content || !dropEmpty) {
              looseSegs.push({ name: lastName, text: content });
              if (content) cleanLines.push(`${lastName}>${content}`);
            }
          }
          lastName = (tag[1] || "").trim();
          lastIndex = tagRe.lastIndex;
        }
        if (lastName !== null) {
          let content = payloadText.slice(lastIndex);
          if (removeTags) content = stripAllTags(content);
          if (doTrim) content = normalizeSpaces(content);
          if (content || !dropEmpty) {
            looseSegs.push({ name: lastName, text: content });
            if (content) cleanLines.push(`${lastName}>${content}`);
          }
        }

        if (looseSegs.length) {
          if (Number.isFinite(startS) && Number.isFinite(endS) && endS >= startS) {
            cues.push({ startS, endS, speakers: looseSegs });
          }
          continue;
        }

        let line = payloadText;
        if (removeTags) line = stripAllTags(line);
        if (doTrim) line = normalizeSpaces(line);
        if (!line && dropEmpty) continue;

        const m2 = line.match(/^(.{2,80}?)[\uFF1A:]\s*(.+)$/);
        if (m2) {
          const speaker = doTrim ? normalizeSpaces(m2[1]) : m2[1].trim();
          const content = doTrim ? normalizeSpaces(m2[2]) : m2[2].trim();
          if (!content && dropEmpty) continue;
          cleanLines.push(`${speaker}>${content}`);
          if (Number.isFinite(startS) && Number.isFinite(endS) && endS >= startS) {
            cues.push({ startS, endS, speakers: [{ name: speaker, text: content }] });
          }
        } else {
          cleanLines.push(line);
        }
      }

      return { cleanText: cleanLines.join("\n"), cues };
    }

    function computeStats(cues) {
      let minS = Infinity;
      let maxE = -Infinity;
      const personSeconds = new Map();
      const presence = new Set();

      for (const cue of cues) {
        if (!Number.isFinite(cue.startS) || !Number.isFinite(cue.endS)) continue;
        minS = Math.min(minS, cue.startS);
        maxE = Math.max(maxE, cue.endS);

        const dur = Math.max(0, cue.endS - cue.startS);
        const speakers = cue.speakers || [];
        if (!speakers.length) continue;

        const uniqueNames = Array.from(new Set(speakers.map(s => s.name).filter(Boolean)));
        uniqueNames.forEach(n => presence.add(n));

        const share = uniqueNames.length ? dur / uniqueNames.length : 0;
        for (const name of uniqueNames) {
          personSeconds.set(name, (personSeconds.get(name) || 0) + share);
        }
      }

      const totalMeeting = (minS !== Infinity && maxE !== -Infinity) ? Math.max(0, maxE - minS) : 0;
      let totalSpeech = 0;
      for (const v of personSeconds.values()) totalSpeech += v;

      const rows = Array.from(personSeconds.entries())
        .map(([name, seconds]) => ({ name, seconds }))
        .sort((a, b) => b.seconds - a.seconds);

      for (const r of rows) r.pct = totalSpeech > 0 ? (r.seconds / totalSpeech) * 100 : 0;

      return {
        totalMeeting,
        totalSpeech,
        presence: Array.from(presence).sort((a, b) => a.localeCompare(b, undefined)),
        rows,
      };
    }

    function getMeetingTitleParts() {
      const typed = (meetingTitleEl.value || "").trim();
      const inferred = (meetingTitleEl.getAttribute("data-inferred") || "").trim();
      const title = typed || inferred || "(sem t\u00edtulo)";
      const notes = (meetingNotesEl.value || "").trim();
      return { title, notes };
    }

    function updateTitlePill() {
      const { title, notes } = getMeetingTitleParts();
      const sep = " \u2022 ";
      pillTitle.textContent = notes ? `T\u00edtulo: ${title}${sep}${notes}` : `T\u00edtulo: ${title}`;
    }

    function renderStats(stats) {
      pillTotal.textContent = `Dura\u00e7\u00e3o total: ${formatDuration(stats.totalMeeting)}`;
      pillPeople.textContent = `Participantes: ${stats.presence.length}`;

      const startDT = buildMeetingDateTime();
      if (startDT) {
        metaWhen.textContent = `Data/hora: ${formatLocalDateTime(startDT)}`;
        const endDT = new Date(startDT.getTime() + Math.round(stats.totalMeeting * 1000));
        metaEnd.textContent = `T\u00e9rmino estimado: ${formatLocalDateTime(endDT)}`;
      } else {
        metaWhen.textContent = "Data/hora: \u2014";
        metaEnd.textContent = "T\u00e9rmino estimado: \u2014";
      }

      statsBody.innerHTML = "";
      if (!stats.rows.length) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="4" style="color: var(--muted);">Nenhum dado de fala encontrado (verifique se o VTT cont\u00e9m timestamps + &lt;v Nome&gt;...&lt;/v&gt;).</td>`;
        statsBody.appendChild(tr);
        return;
      }

      const maxPct = Math.max(...stats.rows.map(r => r.pct));

      for (const r of stats.rows) {
        const tr = document.createElement("tr");
        const pctStr = `${r.pct.toFixed(1)}%`;
        const w = maxPct > 0 ? (r.pct / maxPct) * 100 : 0;
        tr.innerHTML = `
          <td><strong>${escapeHtml(r.name)}</strong></td>
          <td>${formatDuration(r.seconds)}</td>
          <td>${pctStr}</td>
          <td><div class="bar" title="${pctStr}"><div style="width:${w.toFixed(1)}%"></div></div></td>
        `;
        statsBody.appendChild(tr);
      }
    }

    function renderTimeline(cues, stats) {
      timelineChart.classList.add("chartEmpty");
      timelineChart.innerHTML = "Sem dados suficientes para o gr\u00e1fico.";
      timelineLegend.innerHTML = "";
      timelineMeta.textContent = "\u2014";
      timelineStart.textContent = "In\u00edcio";
      timelineEnd.textContent = "Fim";

      if (!cues || !cues.length || !stats || !Number.isFinite(stats.totalMeeting) || stats.totalMeeting <= 0) {
        return;
      }

      const bucketSeconds = pickBucketSeconds(stats.totalMeeting);
      const orderDesc = (stats.rows || []).map(r => r.name);
      const timeline = computeTimeline(cues, orderDesc, bucketSeconds);
      if (!timeline || timeline.maxBucketSeconds <= 0) {
        return;
      }

      const colorMap = new Map();
      timeline.order.forEach((name, idx) => {
        colorMap.set(name, speakerColors[idx % speakerColors.length]);
      });

      timelineChart.classList.remove("chartEmpty");
      timelineChart.innerHTML = "";

      const orderAsc = Array.from(timeline.order).reverse();
      for (let i = 0; i < timeline.bucketCount; i++) {
        const bar = document.createElement("div");
        bar.className = "chartBar";
        const bucketStart = i * timeline.bucketSeconds;
        const bucketEnd = Math.min((i + 1) * timeline.bucketSeconds, stats.totalMeeting);
        bar.title = `${formatDuration(bucketStart)} \u2192 ${formatDuration(bucketEnd)}`;

        for (const name of orderAsc) {
          const arr = timeline.buckets.get(name);
          const secs = arr ? arr[i] : 0;
          if (!secs) continue;
          const seg = document.createElement("div");
          seg.className = "chartSeg";
          const h = (secs / timeline.maxBucketSeconds) * 100;
          seg.style.height = `${h.toFixed(2)}%`;
          seg.style.background = colorMap.get(name);
          seg.title = `${name}: ${formatDuration(secs)}`;
          bar.appendChild(seg);
        }
        timelineChart.appendChild(bar);
      }

      const maxMinutes = timeline.maxBucketSeconds / 60;
      timelineMeta.textContent = `Resolu\u00e7\u00e3o: ${formatBucketLabel(bucketSeconds)} \u2022 Pico: ${maxMinutes.toFixed(1)} min`;
      timelineStart.textContent = "0:00";
      timelineEnd.textContent = formatDuration(stats.totalMeeting);

      for (const name of timeline.order) {
        const item = document.createElement("div");
        item.className = "legendItem";
        const swatch = document.createElement("span");
        swatch.className = "legendSwatch";
        swatch.style.background = colorMap.get(name);
        const label = document.createElement("span");
        label.textContent = name;
        item.appendChild(swatch);
        item.appendChild(label);
        timelineLegend.appendChild(item);
      }
    }

    function padRight(s, n) {
      s = String(s);
      return s.length >= n ? s : s + " ".repeat(n - s.length);
    }

    function buildPlainTextTable(stats) {
      const rows = stats.rows || [];
      const header1 = "Participante";
      const header2 = "Tempo";
      const header3 = "% fala";

      const nameW = Math.min(40, Math.max(header1.length, ...rows.map(r => String(r.name).length)));
      const timeW = Math.max(header2.length, ...rows.map(r => formatDuration(r.seconds).length));
      const pctW = Math.max(header3.length, ...rows.map(r => `${r.pct.toFixed(1)}%`.length));

      const lines = [];
      lines.push(`${padRight(header1, nameW)}  ${padRight(header2, timeW)}  ${padRight(header3, pctW)}`);
      lines.push(`${"-".repeat(nameW)}  ${"-".repeat(timeW)}  ${"-".repeat(pctW)}`);

      for (const r of rows) {
        const pct = `${r.pct.toFixed(1)}%`;
        lines.push(`${padRight(r.name, nameW)}  ${padRight(formatDuration(r.seconds), timeW)}  ${padRight(pct, pctW)}`);
      }
      return lines.join("\n");
    }

    function buildPlainTextSummary(stats) {
      const { title, notes } = getMeetingTitleParts();
      const startDT = buildMeetingDateTime();
      const startStr = startDT ? formatLocalDateTime(startDT) : "\u2014";

      const participants = (stats.presence || []).join(", ") || "\u2014";
      const totalMeetingStr = formatDuration(stats.totalMeeting);
      const totalSpeechStr = formatDuration(stats.totalSpeech);

      const lines = [];
      lines.push(`T\u00edtulo: ${title}`);
      if (notes) lines.push(`Observa\u00e7\u00f5es: ${notes}`);
      lines.push(`In\u00edcio: ${startStr}`);
      lines.push(`Participantes (${(stats.presence || []).length}): ${participants}`);
      lines.push(`Tempo total da reuni\u00e3o: ${totalMeetingStr}`);
      lines.push(`Tempo total de fala (estimado): ${totalSpeechStr}`);
      lines.push("");
      lines.push("Fala por participante:");
      lines.push(buildPlainTextTable(stats));
      return lines.join("\n");
    }

    function buildFinalOutput(transcriptCleanText, stats) {
      const summary = buildPlainTextSummary(stats);
      const transcript = (transcriptCleanText || "").trim();
      return transcript ? `${summary}\n\nTranscri\u00e7\u00e3o:\n${transcript}\n` : `${summary}\n`;
    }

    async function readFileAsText(file) {
      return await file.text();
    }

    function applyInferredTitle(filename) {
      const inferred = inferTitleFromFilename(filename);
      meetingTitleEl.setAttribute("data-inferred", inferred);
      updateTitlePill();
    }

    fileEl.addEventListener("change", async () => {
      const f = fileEl.files && fileEl.files[0];
      if (!f) return;
      try {
        const lower = f.name.toLowerCase();
        applyInferredTitle(f.name);
        if (lower.endsWith(".docx")) {
          activeSource = "docx";
          setStatus(`Lendo DOCX: ${f.name}...`);
          const buffer = await f.arrayBuffer();
          logDebug("DOCX carregando", { name: f.name, size: f.size });
          const docXml = await extractDocxDocumentXml(buffer);
          logDebug("DOCX XML extra\u00eddo", { chars: docXml.length });
          const parsed = parseDocxSegments(docXml);
          logDebug("DOCX parse conclu\u00eddo", { segments: parsed.segments.length, lines: parsed.cleanText.split("\n").filter(Boolean).length });
          lastDocx = parsed;
          inputEl.value = parsed.cleanText || "";
          setStatus(`DOCX carregado: ${f.name} (${parsed.segments.length} fala(s))`);
        } else {
          activeSource = "vtt";
          lastDocx = null;
          setStatus(`Lendo: ${f.name}...`);
          const content = await readFileAsText(f);
          inputEl.value = content;
          setStatus(`Arquivo carregado: ${f.name}`);
        }
      } catch (e) {
        console.error(e);
        setStatus(e && e.message ? e.message : "Falha ao ler o arquivo.");
      }
    });

    meetingTitleEl.addEventListener("input", () => {
      updateTitlePill();
      refreshOutputIfReady();
    });
    meetingNotesEl.addEventListener("input", () => {
      updateTitlePill();
      refreshOutputIfReady();
    });

    inputEl.addEventListener("input", () => {
      activeSource = "vtt";
    });

    let activeSource = "vtt";
    let lastDocx = null;

    let lastStats = { totalMeeting: 0, totalSpeech: 0, presence: [], rows: [] };
    let lastCues = [];
    let lastCleanText = "";
    let lastProcessed = false;

    function refreshOutputIfReady() {
      if (!lastProcessed) return;
      outputEl.value = buildFinalOutput(lastCleanText, lastStats);
    }

    function reprocessFromInput(options = {}) {
      activeSource = "vtt";
      const raw = inputEl.value || "";
      if (!raw.trim()) {
        if (!options.silent) {
          setStatus("Nenhuma entrada para processar.");
        }
        outputEl.value = "";
        setOutStatus("\u2014");
        lastStats = { totalMeeting: 0, totalSpeech: 0, presence: [], rows: [] };
        lastCues = [];
        lastCleanText = "";
        lastProcessed = false;
        renderStats(lastStats);
        renderTimeline(lastCues, lastStats);
        updateTitlePill();
        return false;
      }
      try {
        const parsed = parseVtt(raw);
        lastStats = computeStats(parsed.cues);
        lastCues = parsed.cues || [];
        lastCleanText = parsed.cleanText || "";
        lastProcessed = true;
        renderStats(lastStats);
        renderTimeline(lastCues, lastStats);
        updateTitlePill();
        outputEl.value = buildFinalOutput(lastCleanText, lastStats);
        const count = lastCleanText ? lastCleanText.split("\n").filter(Boolean).length : 0;
        if (!options.silent) {
          setStatus("Processado.");
        }
        setOutStatus(`${count} linha(s) na transcri\u00e7\u00e3o`);
        return true;
      } catch (e) {
        console.error(e);
        if (!options.silent) {
          setStatus("Erro ao processar.");
        }
        return false;
      }
    }

    function reprocessFromDocx(options = {}) {
      activeSource = "docx";
      if (!lastDocx || !lastDocx.segments || !lastDocx.segments.length) {
        if (!options.silent) {
          setStatus("Nenhum DOCX carregado.");
        }
        logDebug("DOCX sem segmentos para processar", { hasDocx: !!lastDocx, segments: lastDocx && lastDocx.segments ? lastDocx.segments.length : 0 });
        outputEl.value = "";
        setOutStatus("\u2014");
        lastStats = { totalMeeting: 0, totalSpeech: 0, presence: [], rows: [] };
        lastCues = [];
        lastCleanText = "";
        lastProcessed = false;
        renderStats(lastStats);
        renderTimeline(lastCues, lastStats);
        updateTitlePill();
        return false;
      }
      try {
        const cues = buildDocxCuesFromSegments(lastDocx.segments);
        lastStats = computeStats(cues);
        lastCues = cues;
        lastCleanText = lastDocx.cleanText || "";
        lastProcessed = true;
        renderStats(lastStats);
        renderTimeline(lastCues, lastStats);
        updateTitlePill();
        outputEl.value = buildFinalOutput(lastCleanText, lastStats);
        const count = lastCleanText ? lastCleanText.split("\n").filter(Boolean).length : 0;
        if (!options.silent) {
          setStatus("Processado (DOCX).");
        }
        setOutStatus(`${count} linha(s) na transcri\u00e7\u00e3o`);
        return true;
      } catch (e) {
        console.error(e);
        if (!options.silent) {
          setStatus("Erro ao processar DOCX.");
        }
        return false;
      }
    }

    function reprocess(options = {}) {
      if (activeSource === "docx") {
        return reprocessFromDocx(options);
      }
      return reprocessFromInput(options);
    }

    meetingDateEl.addEventListener("input", () => {
      meetingDateEl.value = formatDateInput(meetingDateEl.value);
      renderStats(lastStats);
      refreshOutputIfReady();
    });

    meetingStartEl.addEventListener("input", () => {
      meetingStartEl.value = formatTimeInput(meetingStartEl.value);
      renderStats(lastStats);
      refreshOutputIfReady();
    });

    $("process").addEventListener("click", () => {
      reprocess({ silent: false });
    });

    $("clear").addEventListener("click", () => {
      inputEl.value = "";
      outputEl.value = "";
      fileEl.value = "";
      meetingTitleEl.value = "";
      meetingTitleEl.setAttribute("data-inferred", "");
      meetingNotesEl.value = "";
      updateTitlePill();
      setStatus("Pronto.");
      setOutStatus("\u2014");
      pillTotal.textContent = "Dura\u00e7\u00e3o total: \u2014";
      pillPeople.textContent = "Participantes: \u2014";
      activeSource = "vtt";
      lastDocx = null;
      lastStats = { totalMeeting: 0, totalSpeech: 0, presence: [], rows: [] };
      lastCues = [];
      lastCleanText = "";
      lastProcessed = false;
      renderStats(lastStats);
      renderTimeline(lastCues, lastStats);
    });

    $("copy").addEventListener("click", async () => {
      try {
        const text = outputEl.value || "";
        if (!text.trim()) {
          setOutStatus("Nada para copiar");
          return;
        }
        await navigator.clipboard.writeText(text);
        setOutStatus("Copiado");
      } catch {
        outputEl.focus();
        outputEl.select();
        const ok = document.execCommand("copy");
        setOutStatus(ok ? "Copiado" : "N\u00e3o foi poss\u00edvel copiar");
      }
    });

    $("download").addEventListener("click", () => {
      const text = outputEl.value || "";
      if (!text.trim()) {
        setOutStatus("Nada para baixar");
        return;
      }
      const inferred = meetingTitleEl.getAttribute("data-inferred") || "";
      const title = (meetingTitleEl.value || inferred || "transcricao").trim();
      const safeTitle = title.replace(/[^\w\d\-\s]+/g, "").trim().replace(/\s+/g, "-").toLowerCase();
      const stamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, "-");
      const filename = `${safeTitle || "transcricao"}-limpa-${stamp}.txt`;

      const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      setOutStatus("Download iniciado");
    });

    updateTitlePill();
    renderStats(lastStats);
    renderTimeline(lastCues, lastStats);
  </script>
</body>
</html>
