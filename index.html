<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Limpador VTT/DOCX &rarr; TXT + M&eacute;tricas</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root{
      color-scheme: light dark;
      --page: linear-gradient(180deg, #f4f6fb 0%, #e9eef7 100%);
      --bg:#f4f6fb; --fg:#0f172a; --muted:#586274;
      --card:#ffffff; --border:#e0e6ef; --border2:#cfd6e2;
      --field: rgba(15, 23, 42, 0.04);
      --btn:#eef2f8; --btnBorder:#c6cfdd;
      --primary:#5b5fc7; --primaryBorder:#4b4fb1; --primaryText:#ffffff;
      --success:#22c55e; --warning:#f59e0b;
      --shadow: 0 12px 30px rgba(15, 23, 42, 0.12);
      --shadowSoft: 0 8px 20px rgba(15, 23, 42, 0.08);
      --sans: "Inter", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --r: 18px;
    }
    :root[data-theme="dark"]{
      --page: linear-gradient(180deg, #0b1220 0%, #0a0f1a 100%);
      --bg:#0b1220; --fg:#e5e7eb; --muted:#9aa3b2;
      --card:#121826; --border:#273043; --border2:#3b4661;
      --field: rgba(255, 255, 255, 0.05);
      --btn:#1b2433; --btnBorder:#2f3a52;
      --primary:#6d6ff0; --primaryBorder:#8486ff; --primaryText:#f8fafc;
      --success:#34d399; --warning:#fbbf24;
      --shadow: 0 16px 40px rgba(0,0,0,0.4);
      --shadowSoft: 0 10px 24px rgba(0,0,0,0.3);
    }
    @media (prefers-color-scheme: dark){
      :root:not([data-theme="light"]){
        --page: linear-gradient(180deg, #0b1220 0%, #0a0f1a 100%);
        --bg:#0b1220; --fg:#e5e7eb; --muted:#9aa3b2;
        --card:#121826; --border:#273043; --border2:#3b4661;
        --field: rgba(255, 255, 255, 0.05);
        --btn:#1b2433; --btnBorder:#2f3a52;
        --primary:#6d6ff0; --primaryBorder:#8486ff; --primaryText:#f8fafc;
        --success:#34d399; --warning:#fbbf24;
        --shadow: 0 16px 40px rgba(0,0,0,0.4);
        --shadowSoft: 0 10px 24px rgba(0,0,0,0.3);
      }
    }
    *{box-sizing:border-box}
    body{margin:0; padding:28px; font-family: var(--sans); font-size:14px; line-height:1.5; background: transparent; color: var(--fg); position: relative; overflow-x:hidden}
    body::before{
      content:"";
      position: fixed;
      inset:0;
      background: var(--page);
      z-index:-1;
    }
    .wrap{max-width: 1120px; margin:0 auto}

    .top{display:flex; flex-direction:column; gap:10px; margin-bottom:16px}
    h1{font-size:20px; margin:0; letter-spacing:0.2px}
    .sub{margin:0; font-size:13px; color:var(--muted)}

    .topHeading{display:flex; flex-wrap:wrap; align-items:flex-start; justify-content:space-between; gap:12px}
    .topHeading h1{flex:1 1 320px}
    .topHeading button{flex-shrink:0}
    .topDesc{display:flex; flex-direction:column; gap:4px}
    .pillGroup{display:flex; gap:8px; flex-wrap:wrap}

    .pill{display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid var(--border); background: rgba(91, 95, 199, 0.08); font-size:12px; color: var(--muted); white-space:nowrap}
    .kbd{font-family: var(--mono); border:1px solid var(--border2); border-bottom-width:2px; padding:1px 6px; border-radius:9px; font-size:12px; opacity:0.95}

    .stack{display:flex; flex-direction:column; gap:18px; margin-top:16px}
    .mainGrid{
      display:grid;
      gap:18px;
      grid-template-columns: 1fr;
    }
    .colStack{display:flex; flex-direction:column; gap:18px}
    @media (min-width: 980px){
      .mainGrid{
        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
        align-items:start;
      }
    }

    .card{border:1px solid var(--border); border-radius: var(--r); padding:18px; background: var(--card); box-shadow: var(--shadow)}
    .card h2{font-size:15px; margin:0 0 12px; opacity:0.95}

    .row{display:grid; grid-template-columns: 1fr; gap:12px}
    @media (min-width: 720px){
      .row.cols2{grid-template-columns: 1fr 1fr}
      .row.cols3{grid-template-columns: 1fr 1fr 1fr}
    }

    label{display:block; font-weight:600; font-size:12px; margin:0 0 6px; opacity:0.92}
    input[type=file], input[type=text]{
      width:100%; padding:11px 12px; border-radius:12px; border:1px solid var(--border2);
      background: var(--field); color: var(--fg); outline:none;
    }

    textarea{
      width:100%; min-height:240px; padding:12px; border-radius:12px; border:1px solid var(--border2);
      background: var(--field); color: var(--fg); outline:none;
      font-family: var(--mono); font-size:12.5px; resize: vertical;
    }

    .controls{display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-top:12px}
    button{border:1px solid var(--btnBorder); background: var(--btn); color: var(--fg); padding:10px 14px; border-radius:8px; cursor:pointer; font-weight:700; transition: transform 0.12s ease, box-shadow 0.2s ease}
    button.primary{background: var(--primary); border-color: var(--primaryBorder); color: var(--primaryText); box-shadow: 0 10px 18px rgba(91, 95, 199, 0.25)}
    button.ghost{background: transparent; border-color: var(--border2); box-shadow:none}
    button:active{transform: translateY(1px)}
    .status{margin-left:auto; font-size:12px; color: var(--muted); font-weight:600}
    .status.success{color: var(--success)}
    .status.warn{color: var(--warning)}
    .status.muted{color: var(--muted)}
    .hint{font-size:12px; color: var(--muted); margin-top:8px}

    .dropzone{
      border:1.5px dashed var(--border2);
      border-radius:12px;
      padding:14px 16px;
      background: rgba(91, 95, 199, 0.06);
      color: var(--muted);
      cursor:pointer;
      transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .dropzoneText{display:flex; flex-direction:column; gap:2px}
    .dropzone .dropTitle{font-weight:700; color: var(--fg); font-size:13px}
    .dropzone .dropHint{font-size:12px}
    .dropzoneActions{display:flex; align-items:center; gap:8px}
    .dropzone.dragover{
      border-color: var(--primaryBorder);
      background: rgba(91, 95, 199, 0.14);
      color: var(--fg);
    }
    .card.dragover{
      border-color: var(--primaryBorder);
      box-shadow: 0 0 0 2px rgba(91, 95, 199, 0.15), var(--shadow);
    }
    .dropzone:focus-visible{
      outline: 2px solid var(--primaryBorder);
      outline-offset: 2px;
    }
    @media (max-width: 560px){
      .dropzone{flex-direction:column; align-items:flex-start}
      .dropzoneActions{width:100%}
      .dropzoneActions button{width:100%}
    }
    .dropMeta{margin-top:6px; font-size:12px; color: var(--muted)}
    .visuallyHidden{
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip: rect(0, 0, 0, 0);
      white-space:nowrap;
      border:0;
    }

    table{width:100%; border-collapse:separate; border-spacing:0; overflow:hidden; border-radius:14px; border:1px solid var(--border); margin-top:10px}
    .metricsTable{table-layout: fixed}
    .metricsTable th:nth-child(2), .metricsTable td:nth-child(2){min-width:72px}
    .metricsTable th:nth-child(3), .metricsTable td:nth-child(3){min-width:64px}
    th, td{padding:10px; border-bottom:1px solid var(--border); font-size:12.5px; text-align:left; vertical-align:top}
    th{font-size:12px; color: var(--muted); font-weight:900; white-space:nowrap}
    tr:last-child td{border-bottom:none}

    .bar{height:10px; border-radius:999px; border:1px solid var(--border); background: rgba(127,127,127,0.08); overflow:hidden}
    .bar > div{height:100%; background: var(--primaryBorder); width:0%}

    .metricsSticky{
      position: sticky;
      top: 16px;
      z-index: 3;
      padding:10px 12px;
      border:1px solid var(--border);
      border-radius:12px;
      background: var(--card);
      box-shadow: var(--shadowSoft);
      margin-bottom:14px;
    }
    .metricsStickyTitle{font-size:11px; font-weight:700; text-transform:uppercase; letter-spacing:0.08em; color: var(--muted); margin-bottom:6px}
    .metricsPills{display:flex; flex-wrap:wrap; gap:8px}

    .metricSection{margin-top:16px}
    .metricSection:first-of-type{margin-top:10px}
    .metricSection table{margin-top:0}
    .chartHeader{display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:10px}
    .chartTitle{font-size:12px; font-weight:800; opacity:0.92}
    .chartMeta{font-size:12px; color: var(--muted)}
    .chartGrid{
      height:220px; display:flex; align-items:stretch; gap:2px; padding:8px 6px;
      border:1px solid var(--border); border-radius:14px;
      background: linear-gradient(to top, rgba(127,127,127,0.12) 1px, transparent 1px);
      background-size: 100% 25%;
    }
    .chartBar{flex:1 1 0; display:flex; flex-direction:column-reverse; min-width:2px; height:100%}
    .chartSeg{width:100%; min-height:1px}
    .chartAxis{display:flex; justify-content:space-between; font-size:12px; color: var(--muted); margin-top:6px}
    .legend{display:flex; flex-wrap:wrap; gap:8px 12px; margin-top:8px}
    .legendItem{display:flex; align-items:center; gap:6px; font-size:12px; color: var(--muted)}
    .legendSwatch{width:12px; height:12px; border-radius:3px; border:1px solid var(--border)}
    .chartEmpty{display:flex; align-items:center; justify-content:center; font-size:12.5px; color: var(--muted); font-weight:600}
    .emptyState{font-size:12.5px; color: var(--muted); font-weight:600}
    .wordCloud{
      height:320px; padding:12px 14px; border:1px solid var(--border); border-radius:14px;
      background:
        radial-gradient(circle at 20% 20%, rgba(127,127,127,0.10), transparent 55%),
        radial-gradient(circle at 80% 70%, rgba(127,127,127,0.08), transparent 60%);
      text-align:center;
    }
    .wordCloud.chartEmpty{color: var(--muted); font-size:12.5px}

    /* jQCloud styles */
    div.jqcloud { font-size: 13px; line-height: normal; overflow: hidden; position: relative; margin: 0; }
    div.jqcloud a { font-size: inherit; text-decoration: none; }
    div.jqcloud span.w10 { font-size: 550%; }
    div.jqcloud span.w9 { font-size: 500%; }
    div.jqcloud span.w8 { font-size: 450%; }
    div.jqcloud span.w7 { font-size: 400%; }
    div.jqcloud span.w6 { font-size: 350%; }
    div.jqcloud span.w5 { font-size: 300%; }
    div.jqcloud span.w4 { font-size: 250%; }
    div.jqcloud span.w3 { font-size: 200%; }
    div.jqcloud span.w2 { font-size: 150%; }
    div.jqcloud span.w1 { font-size: 100%; }
    div.jqcloud { color: #2BA0FD; }
    div.jqcloud span.w10 { color: #3D5A68; }
    div.jqcloud span.w9 { color: #563225; }
    div.jqcloud span.w8 { color: #DC7500; }
    div.jqcloud span.w7 { color: #298C2D; }
    div.jqcloud span.w6 { color:  #0073D0; }
    div.jqcloud span.w5 { color:  #1C2E92; }
    div.jqcloud span.w4 { color: #441794; }
    div.jqcloud span.w3 { color: #79048D; }
    div.jqcloud span.w2 { color: #C60040; }
    div.jqcloud span.w1 { color: #D12013; }
    div.jqcloud span.c1 { color: #D12013; }
    div.jqcloud span.c2 { color: #C60040; }
    div.jqcloud span.c3 { color: #79048D; }
    div.jqcloud span.c4 { color: #441794; }
    div.jqcloud span.c5 { color: #1C2E92; }
    div.jqcloud span.c6 { color: #0073D0; }
    div.jqcloud span.c7 { color: #298C2D; }
    div.jqcloud span.c8 { color: #DC7500; }
    div.jqcloud span.c9 { color: #563225; }
    div.jqcloud span.c10 { color: #3D5A68; }
    div.jqcloud span:hover { color: #0099B2; }
    div.jqcloud span { padding: 0; }
    div.jqcloud.wordCloud.chartEmpty { color: var(--muted); font-size:12.5px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="topHeading">
        <h1>Limpador de transcri&ccedil;&atilde;o (.vtt/.docx) &rarr; TXT + m&eacute;tricas de fala</h1>
        <button class="ghost" id="themeToggle" type="button" aria-pressed="false">Modo escuro</button>
      </div>
      <div class="topDesc">
        <p class="sub">Gera linhas <span class="kbd">Nome&gt;Texto</span> e calcula tempo por participante. Para DOCX, o tempo &eacute; estimado.</p>
        <p class="sub">Primeira vez? Carregue um .vtt ou .docx (ou cole VTT) e clique em Processar.</p>
      </div>
      <div class="pillGroup">
        <span class="pill" id="pillTitle">T&iacute;tulo: &mdash;</span>
        <span class="pill" id="pillTotal">Dura&ccedil;&atilde;o total: Sem dados</span>
        <span class="pill" id="pillPeople">Participantes: Sem dados</span>
      </div>
    </div>

    <div class="stack mainGrid">
      <div class="colStack">
        <div class="card" id="cardConfig">
          <h2>Arquivo</h2>
          <div>
            <label for="file">Arquivo .vtt ou .docx</label>
            <div class="dropzone" id="dropzone" role="button" tabindex="0" aria-label="Arraste e solte no card inteiro ou clique para selecionar">
              <div class="dropzoneText">
                  <div class="dropTitle">Arraste e solte no card inteiro para carregar</div>
                <div class="dropHint">ou selecione um arquivo .vtt/.docx</div>
              </div>
              <div class="dropzoneActions">
                <button class="primary" id="pickFile" type="button">Selecionar arquivo</button>
              </div>
            </div>
            <input class="visuallyHidden" id="file" type="file" accept=".vtt,.docx,text/vtt,text/plain,application/vnd.openxmlformats-officedocument.wordprocessingml.document" />
            <div class="dropMeta" id="dropMeta">Nenhum arquivo selecionado</div>
          </div>
          <div class="row cols3" style="margin-top:12px;">
            <div>
              <label for="meetingDate">Dia da reuni&atilde;o (dd/mm/aa)</label>
              <input id="meetingDate" type="text" inputmode="numeric" placeholder="dd/mm/aa" />
            </div>
            <div>
              <label for="meetingStart">Hor&aacute;rio de in&iacute;cio (24h)</label>
              <input id="meetingStart" type="text" inputmode="numeric" placeholder="hh:mm" />
            </div>
            <div>
              <label for="meetingTitle">T&iacute;tulo da reuni&atilde;o (opcional)</label>
              <input id="meetingTitle" type="text" placeholder="(se vazio, usa o nome do arquivo)" />
            </div>
          </div>
          <div class="row" style="margin-top:10px;">
            <div>
              <label for="meetingNotes">Observa&ccedil;&otilde;es (opcional)</label>
              <input id="meetingNotes" type="text" placeholder="ex: Alinhamento comercial" />
            </div>
          </div>
        </div>

        <div class="card" id="cardInput">
          <h2>Entrada</h2>
          <label for="input">Cole aqui o conte&uacute;do do VTT (ou carregue .vtt/.docx acima)</label>
          <textarea id="input" placeholder="Cole aqui o conte&uacute;do do .vtt..."></textarea>
          <div class="controls">
            <button class="primary" id="process">Processar</button>
            <button id="clear">Limpar</button>
            <span class="status" id="status">Pronto.</span>
          </div>
          <div class="hint" style="margin-top:10px;">
            A limpeza aplica: unir quebras internas, normalizar espa&ccedil;os, remover tags e descartar linhas vazias. Para DOCX, o tempo &eacute; estimado.
          </div>
        </div>
      </div>

      <div class="colStack">
        <div class="card" id="cardOutput">
          <h2>Sa&iacute;da (TXT limpo)</h2>
          <label for="output">Resumo + tabela (texto puro) + transcri&ccedil;&atilde;o</label>
          <textarea id="output" readonly placeholder="O resultado aparecer&aacute; aqui..."></textarea>
          <div class="controls">
            <button class="primary" id="copy">Copiar</button>
            <button id="download">Baixar .txt</button>
            <span class="status" id="outStatus">&mdash;</span>
          </div>
        </div>

        <div class="card" id="cardMetrics">
          <h2>M&eacute;tricas</h2>
          <div class="metricsSticky" id="metricsSticky">
            <div class="metricsStickyTitle">Resumo</div>
            <div class="metricsPills">
              <span class="pill" id="pillTotalSticky">Dura&ccedil;&atilde;o total: Sem dados</span>
              <span class="pill" id="pillPeopleSticky">Participantes: Sem dados</span>
            </div>
          </div>
          <div class="metricSection">
            <div class="chartHeader">
              <div class="chartTitle">Tempo de fala</div>
            </div>
            <table class="metricsTable" aria-label="Tabela de m&eacute;tricas">
              <colgroup>
                <col style="width:36%">
                <col style="width:20%">
                <col style="width:16%">
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>Participante</th>
                  <th>Tempo</th>
                  <th>% fala</th>
                  <th>Distribui&ccedil;&atilde;o</th>
                </tr>
              </thead>
              <tbody id="statsBody">
                <tr><td colspan="4" class="emptyState">Sem dados</td></tr>
              </tbody>
            </table>
          </div>

          <div class="metricSection">
            <div class="chartHeader">
              <div class="chartTitle">Turnos (interven&ccedil;&otilde;es)</div>
              <div class="chartMeta" id="turnsMeta">Sem dados</div>
            </div>
            <table class="metricsTable" aria-label="Tabela de turnos">
              <colgroup>
                <col style="width:36%">
                <col style="width:18%">
                <col style="width:16%">
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>Participante</th>
                  <th>Turnos</th>
                  <th>% turnos</th>
                  <th>Distribui&ccedil;&atilde;o</th>
                </tr>
              </thead>
              <tbody id="turnsBody">
                <tr><td colspan="4" class="emptyState">Sem dados</td></tr>
              </tbody>
            </table>
          </div>

          <div class="metricSection">
            <div class="chartHeader">
              <div class="chartTitle">Nuvem de palavras</div>
              <div class="chartMeta" id="wordCloudMeta">Sem dados</div>
            </div>
            <div class="wordCloud jqcloud chartEmpty" id="wordCloud" role="img" aria-label="Nuvem de palavras">
              Sem dados
            </div>
          </div>

          <div class="metricSection">
            <div class="chartHeader">
              <div class="chartTitle">Fala ao longo do tempo</div>
              <div class="chartMeta" id="timelineMeta">Sem dados</div>
            </div>
            <div class="chartGrid chartEmpty" id="timelineChart" role="img" aria-label="Fala ao longo do tempo">
              Sem dados
            </div>
            <div class="chartAxis">
              <span id="timelineStart">In&iacute;cio</span>
              <span id="timelineEnd">Fim</span>
            </div>
            <div class="legend" id="timelineLegend"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    const themeToggle = $("themeToggle");
    const fileEl = $("file");
    const dropzone = $("dropzone");
    const dropMeta = $("dropMeta");
    const pickFile = $("pickFile");
    const configCard = $("cardConfig");
    const inputEl = $("input");
    const outputEl = $("output");
    const statusEl = $("status");
    const outStatusEl = $("outStatus");

    const meetingDateEl = $("meetingDate");
    const meetingStartEl = $("meetingStart");
    const meetingTitleEl = $("meetingTitle");
    const meetingNotesEl = $("meetingNotes");

    const pillTitle = $("pillTitle");
    const pillTotal = $("pillTotal");
    const pillPeople = $("pillPeople");
    const pillTotalSticky = $("pillTotalSticky");
    const pillPeopleSticky = $("pillPeopleSticky");

    const statsBody = $("statsBody");
    const turnsBody = $("turnsBody");
    const turnsMeta = $("turnsMeta");
    const timelineChart = $("timelineChart");
    const timelineLegend = $("timelineLegend");
    const timelineMeta = $("timelineMeta");
    const timelineStart = $("timelineStart");
    const timelineEnd = $("timelineEnd");
    const wordCloud = $("wordCloud");
    const wordCloudMeta = $("wordCloudMeta");

    const EMPTY_METRICS_TEXT = "Sem dados";

    function setStatus(msg, tone = "muted") {
      statusEl.textContent = msg;
      statusEl.className = `status ${tone}`;
    }
    function setOutStatus(msg, tone = "muted") {
      outStatusEl.textContent = msg;
      outStatusEl.className = `status ${tone}`;
    }
    function logDebug(...args) { console.log("[debug]", ...args); }

    const THEME_KEY = "tmtc-theme";

    function getSystemPrefersDark() {
      return window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    }

    function setThemeToggleLabel(isDark) {
      if (!themeToggle) return;
      themeToggle.textContent = isDark ? "Modo claro" : "Modo escuro";
      themeToggle.setAttribute("aria-pressed", String(isDark));
    }

    function applyTheme(theme) {
      if (theme === "dark" || theme === "light") {
        document.documentElement.setAttribute("data-theme", theme);
        setThemeToggleLabel(theme === "dark");
        return;
      }
      document.documentElement.removeAttribute("data-theme");
      setThemeToggleLabel(getSystemPrefersDark());
    }

    if (themeToggle) {
      const savedTheme = localStorage.getItem(THEME_KEY);
      applyTheme(savedTheme);
      themeToggle.addEventListener("click", () => {
        const current = document.documentElement.getAttribute("data-theme");
        const isDark = current ? current === "dark" : getSystemPrefersDark();
        const next = isDark ? "light" : "dark";
        localStorage.setItem(THEME_KEY, next);
        applyTheme(next);
      });
    }

    const DEFAULT_SECONDS_PER_CHAR = 0.06;
    const MIN_ESTIMATED_SECONDS = 0.6;
    const WORD_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
    const WORD_CLOUD_MAX = 30;
    const WORD_CLOUD_STOP = new Set(['a', 'à', 'adeus', 'agora', 'aí', 'ainda', 'além', 'algo', 'alguém', 'algum', 'alguma', 'algumas', 'alguns', 'ali', 'ampla', 'amplas', 'amplo', 'amplos', 'ano', 'anos', 'ante', 'antes', 'ao', 'aos', 'apenas', 'apoio', 'após', 'aquela', 'aquelas', 'aquele', 'aqueles', 'aqui', 'aquilo', 'área', 'as', 'às', 'assim', 'até', 'atrás', 'através', 'baixo', 'bastante', 'bem', 'boa', 'boas', 'bom', 'bons', 'breve', 'cá', 'cada', 'catorze', 'cedo', 'cento', 'certamente', 'certeza', 'cima', 'cinco', 'coisa', 'coisas', 'com', 'como', 'conselho', 'contra', 'contudo', 'custa', 'da', 'dá', 'dão', 'daquela', 'daquelas', 'daquele', 'daqueles', 'dar', 'das', 'de', 'debaixo', 'dela', 'delas', 'dele', 'deles', 'demais', 'dentro', 'depois', 'desde', 'dessa', 'dessas', 'desse', 'desses', 'desta', 'destas', 'deste', 'destes', 'deve', 'devem', 'devendo', 'dever', 'deverá', 'deverão', 'deveria', 'deveriam', 'devia', 'deviam', 'dez', 'dezanove', 'dezasseis', 'dezassete', 'dezoito', 'dia', 'diante', 'disse', 'disso', 'disto', 'dito', 'diz', 'dizem', 'dizer', 'do', 'dois', 'dos', 'doze', 'duas', 'dúvida', 'e', 'é', 'ela', 'elas', 'ele', 'eles', 'em', 'embora', 'enquanto', 'entre', 'era', 'eram', 'éramos', 'és', 'essa', 'essas', 'esse', 'esses', 'esta', 'está', 'estamos', 'estão', 'estar', 'estas', 'estás', 'estava', 'estavam', 'estávamos', 'este', 'esteja', 'estejam', 'estejamos', 'estes', 'esteve', 'estive', 'estivemos', 'estiver', 'estivera', 'estiveram', 'estivéramos', 'estiverem', 'estivermos', 'estivesse', 'estivessem', 'estivéssemos', 'estiveste', 'estivestes', 'estou', 'etc', 'eu', 'exemplo', 'faço', 'falta', 'favor', 'faz', 'fazeis', 'fazem', 'fazemos', 'fazendo', 'fazer', 'fazes', 'feita', 'feitas', 'feito', 'feitos', 'fez', 'fim', 'final', 'foi', 'fomos', 'for', 'fora', 'foram', 'fôramos', 'forem', 'forma', 'formos', 'fosse', 'fossem', 'fôssemos', 'foste', 'fostes', 'fui', 'geral', 'grande', 'grandes', 'grupo', 'há', 'haja', 'hajam', 'hajamos', 'hão', 'havemos', 'havia', 'hei', 'hoje', 'hora', 'horas', 'houve', 'houvemos', 'houver', 'houvera', 'houverá', 'houveram', 'houvéramos', 'houverão', 'houverei', 'houverem', 'houveremos', 'houveria', 'houveriam', 'houveríamos', 'houvermos', 'houvesse', 'houvessem', 'houvéssemos', 'isso', 'isto', 'já', 'la', 'lá', 'lado', 'lhe', 'lhes', 'lo', 'local', 'logo', 'longe', 'lugar', 'maior', 'maioria', 'mais', 'mal', 'mas', 'máximo', 'me', 'meio', 'menor', 'menos', 'mês', 'meses', 'mesma', 'mesmas', 'mesmo', 'mesmos', 'meu', 'meus', 'mil', 'minha', 'minhas', 'momento', 'muita', 'muitas', 'muito', 'muitos', 'na', 'nada', 'não', 'naquela', 'naquelas', 'naquele', 'naqueles', 'nas', 'nem', 'nenhum', 'nenhuma', 'nessa', 'nessas', 'nesse', 'nesses', 'nesta', 'nestas', 'neste', 'nestes', 'ninguém', 'nível', 'no', 'noite', 'nome', 'nos', 'nós', 'nossa', 'nossas', 'nosso', 'nossos', 'nova', 'novas', 'nove', 'novo', 'novos', 'num', 'numa', 'número', 'nunca', 'o', 'obra', 'obrigada', 'obrigado', 'oitava', 'oitavo', 'oito', 'onde', 'ontem', 'onze', 'os', 'ou', 'outra', 'outras', 'outro', 'outros', 'para', 'parece', 'parte', 'partir', 'paucas', 'pela', 'pelas', 'pelo', 'pelos', 'pequena', 'pequenas', 'pequeno', 'pequenos', 'per', 'perante', 'perto', 'pode', 'pude', 'pôde', 'podem', 'podendo', 'poder', 'poderia', 'poderiam', 'podia', 'podiam', 'põe', 'põem', 'pois', 'ponto', 'pontos', 'por', 'porém', 'porque', 'porquê', 'posição', 'possível', 'possivelmente', 'posso', 'pouca', 'poucas', 'pouco', 'poucos', 'primeira', 'primeiras', 'primeiro', 'primeiros', 'própria', 'próprias', 'próprio', 'próprios', 'próxima', 'próximas', 'próximo', 'próximos', 'pude', 'puderam', 'quais', 'quáis', 'qual', 'quando', 'quanto', 'quantos', 'quarta', 'quarto', 'quatro', 'que', 'quê', 'quem', 'quer', 'quereis', 'querem', 'queremas', 'queres', 'quero', 'questão', 'quinta', 'quinto', 'quinze', 'relação', 'sabe', 'sabem', 'são', 'se', 'segunda', 'segundo', 'sei', 'seis', 'seja', 'sejam', 'sejamos', 'sem', 'sempre', 'sendo', 'ser', 'será', 'serão', 'serei', 'seremos', 'seria', 'seriam', 'seríamos', 'sete', 'sétima', 'sétimo', 'seu', 'seus', 'sexta', 'sexto', 'si', 'sido', 'sim', 'sistema', 'só', 'sob', 'sobre', 'sois', 'somos', 'sou', 'sua', 'suas', 'tal', 'talvez', 'também', 'tampouco', 'tanta', 'tantas', 'tanto', 'tão', 'tarde', 'te', 'tem', 'tém', 'têm', 'temos', 'tendes', 'tendo', 'tenha', 'tenham', 'tenhamos', 'tenho', 'tens', 'ter', 'terá', 'terão', 'terceira', 'terceiro', 'terei', 'teremos', 'teria', 'teriam', 'teríamos', 'teu', 'teus', 'teve', 'ti', 'tido', 'tinha', 'tinham', 'tínhamos', 'tive', 'tivemos', 'tiver', 'tivera', 'tiveram', 'tivéramos', 'tiverem', 'tivermos', 'tivesse', 'tivessem', 'tivéssemos', 'tiveste', 'tivestes', 'toda', 'todas', 'todavia', 'todo', 'todos', 'trabalho', 'três', 'treze', 'tu', 'tua', 'tuas', 'tudo', 'última', 'últimas', 'último', 'últimos', 'um', 'uma', 'umas', 'uns', 'vai', 'vais', 'vão', 'vários', 'vem', 'vêm', 'vendo', 'vens', 'ver', 'vez', 'vezes', 'viagem', 'vindo', 'vinte', 'vir', 'você', 'vocês', 'vos', 'vós', 'vossa', 'vossas', 'vosso', 'vossos', 'zero', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '_' ]);


    function isTimestampLine(line) {
      return /\d{2}:\d{2}:\d{2}(?:\.\d+)?\s*-->\s*\d{2}:\d{2}:\d{2}(?:\.\d+)?/.test(line);
    }

    function stripAllTags(s) {
      return s.replace(/<[^>]+>/g, "");
    }

    function normalizeSpaces(s) {
      return s.replace(/\u00A0/g, " ").replace(/\s+/g, " ").trim();
    }

    function tokenizeWords(text) {
      return String(text || "")
        .toLowerCase()
        .replace(/[\u2019']/g, "")
        .replace(/[^0-9a-zA-Z\u00C0-\u017F]+/g, " ")
        .split(/\s+/)
        .filter(Boolean);
    }

    function parseTimeToSeconds(ts) {
      const m = ts.match(/^(\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?$/);
      if (!m) return null;
      const hh = Number(m[1]);
      const mm = Number(m[2]);
      const ss = Number(m[3]);
      const ms = m[4] ? Number((m[4] + "000").slice(0, 3)) : 0;
      return (hh * 3600) + (mm * 60) + ss + (ms / 1000);
    }

    function formatDuration(seconds) {
      if (!Number.isFinite(seconds) || seconds < 0) return "\u2014";
      const total = Math.round(seconds);
      const hh = Math.floor(total / 3600);
      const mm = Math.floor((total % 3600) / 60);
      const ss = total % 60;
      const pad2 = (n) => String(n).padStart(2, "0");
      return hh > 0 ? `${hh}:${pad2(mm)}:${pad2(ss)}` : `${mm}:${pad2(ss)}`;
    }

    function countSpeechChars(text) {
      return String(text || "").replace(/\s+/g, "").length;
    }

    const speakerColors = [
      "#2563eb",
      "#f97316",
      "#16a34a",
      "#9333ea",
      "#e11d48",
      "#0ea5e9",
      "#f59e0b",
      "#14b8a6",
      "#84cc16",
      "#db2777",
    ];

    function pickBucketSeconds(totalSeconds) {
      if (totalSeconds <= 300) return 15;
      if (totalSeconds <= 1200) return 30;
      if (totalSeconds <= 3600) return 60;
      if (totalSeconds <= 7200) return 120;
      return 300;
    }

    function formatBucketLabel(seconds) {
      if (seconds % 60 === 0) {
        const mins = seconds / 60;
        return `${mins} min`;
      }
      return `${seconds}s`;
    }

    function computeTimeline(cues, orderDesc, bucketSeconds) {
      let minS = Infinity;
      let maxE = -Infinity;
      for (const cue of cues) {
        if (!Number.isFinite(cue.startS) || !Number.isFinite(cue.endS)) continue;
        minS = Math.min(minS, cue.startS);
        maxE = Math.max(maxE, cue.endS);
      }
      if (minS === Infinity || maxE === -Infinity) return null;

      const total = Math.max(0, maxE - minS);
      const bucketCount = Math.max(1, Math.ceil(total / bucketSeconds));

      const buckets = new Map();
      const order = Array.from(orderDesc || []);

      for (const name of order) {
        buckets.set(name, new Array(bucketCount).fill(0));
      }

      for (const cue of cues) {
        if (!Number.isFinite(cue.startS) || !Number.isFinite(cue.endS)) continue;
        if (cue.endS <= cue.startS) continue;
        const speakers = cue.speakers || [];
        const uniqueNames = Array.from(new Set(speakers.map(s => s.name).filter(Boolean)));
        if (!uniqueNames.length) continue;

        for (const name of uniqueNames) {
          if (!buckets.has(name)) {
            buckets.set(name, new Array(bucketCount).fill(0));
            order.push(name);
          }
        }

        const start = cue.startS;
        const end = cue.endS;
        const firstIdx = Math.max(0, Math.floor((start - minS) / bucketSeconds));
        const lastIdx = Math.min(bucketCount - 1, Math.floor((end - minS) / bucketSeconds));
        const share = 1 / uniqueNames.length;

        for (let idx = firstIdx; idx <= lastIdx; idx++) {
          const bucketStart = minS + idx * bucketSeconds;
          const bucketEnd = bucketStart + bucketSeconds;
          const overlap = Math.max(0, Math.min(end, bucketEnd) - Math.max(start, bucketStart));
          if (overlap <= 0) continue;
          for (const name of uniqueNames) {
            buckets.get(name)[idx] += overlap * share;
          }
        }
      }

      let maxBucketSeconds = 0;
      for (let i = 0; i < bucketCount; i++) {
        let sum = 0;
        for (const name of order) {
          const arr = buckets.get(name);
          sum += arr ? arr[i] : 0;
        }
        if (sum > maxBucketSeconds) maxBucketSeconds = sum;
      }

      return { minS, maxE, bucketCount, bucketSeconds, buckets, order, maxBucketSeconds };
    }

    function inferTitleFromFilename(name) {
      if (!name) return "";
      let base = name.replace(/\.[^.]+$/, "");
      base = base.replace(/[_-]+/g, " ").replace(/\s+/g, " ").trim();
      return base;
    }

    function normalizeDateBr(value) {
      const v = (value || "").trim();
      if (!v) return null;
      const m = v.match(/^(\d{2})\/(\d{2})\/(\d{2}|\d{4})$/);
      if (!m) return null;
      const dd = Number(m[1]);
      const mm = Number(m[2]);
      let yy = Number(m[3]);
      if (yy < 100) yy += 2000;
      if (dd < 1 || dd > 31 || mm < 1 || mm > 12) return null;
      return { dd, mm, yy };
    }

    function normalizeTime24(value) {
      const v = (value || "").trim();
      if (!v) return null;
      const m = v.match(/^([01]\d|2[0-3]):([0-5]\d)$/);
      if (!m) return null;
      return { hh: Number(m[1]), mi: Number(m[2]) };
    }

    function buildMeetingDateTime() {
      const d = normalizeDateBr(meetingDateEl.value);
      const t = normalizeTime24(meetingStartEl.value);
      if (!d || !t) return null;
      const dt = new Date(d.yy, d.mm - 1, d.dd, t.hh, t.mi, 0, 0);
      return isNaN(dt.getTime()) ? null : dt;
    }

    function formatDateInput(value) {
      const digits = String(value || "").replace(/\D/g, "").slice(0, 6);
      if (digits.length <= 2) return digits;
      if (digits.length <= 4) return `${digits.slice(0, 2)}/${digits.slice(2)}`;
      return `${digits.slice(0, 2)}/${digits.slice(2, 4)}/${digits.slice(4)}`;
    }

    function formatTimeInput(value) {
      const digits = String(value || "").replace(/\D/g, "").slice(0, 4);
      if (digits.length <= 2) return digits;
      return `${digits.slice(0, 2)}:${digits.slice(2)}`;
    }

    function formatLocalDateTime(dt) {
      if (!(dt instanceof Date) || isNaN(dt.getTime())) return "\u2014";
      try {
        return new Intl.DateTimeFormat("pt-BR", {
          day: "2-digit",
          month: "2-digit",
          year: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          hourCycle: "h23",
        }).format(dt);
      } catch {
        return dt.toLocaleString("pt-BR");
      }
    }

    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function collectTextSegments(cues, cleanText) {
      const segments = [];
      if (cues && cues.length) {
        for (const cue of cues) {
          const speakers = cue.speakers || [];
          for (const sp of speakers) {
            if (sp && sp.text) segments.push(sp.text);
          }
        }
      }
      if (!segments.length && cleanText) {
        const lines = String(cleanText).split("\n").map(l => l.trim()).filter(Boolean);
        for (const line of lines) {
          let content = line;
          const arrowIdx = line.indexOf(">");
          if (arrowIdx > 0 && arrowIdx < 60) {
            const after = line.slice(arrowIdx + 1).trim();
            if (after) content = after;
          } else {
            const colonIdx = line.indexOf(":");
            if (colonIdx > 0 && colonIdx < 60) {
              const after = line.slice(colonIdx + 1).trim();
              if (after) content = after;
            }
          }
          if (content) segments.push(content);
        }
      }
      return segments;
    }

    function computeWordCloudData(cues, cleanText) {
      const segments = collectTextSegments(cues, cleanText);
      const freq = new Map();
      let totalTokens = 0;

      for (const segment of segments) {
        const tokens = tokenizeWords(segment);
        for (const token of tokens) {
          if (token.length < 3) continue;
          if (/^\d+$/.test(token)) continue;
          if (WORD_CLOUD_STOP.has(token)) continue;
          freq.set(token, (freq.get(token) || 0) + 1);
          totalTokens++;
        }
      }

      const words = Array.from(freq.entries())
        .map(([word, count]) => ({ word, count }))
        .sort((a, b) => (b.count - a.count) || a.word.localeCompare(b.word, "pt-BR"));

      return {
        words: words.slice(0, WORD_CLOUD_MAX),
        uniqueCount: freq.size,
        totalTokens,
        limit: WORD_CLOUD_MAX,
      };
    }

    function findZipEocdOffset(view) {
      const min = Math.max(0, view.byteLength - 0x10000 - 22);
      for (let i = view.byteLength - 22; i >= min; i--) {
        if (view.getUint32(i, true) === 0x06054b50) return i;
      }
      return -1;
    }

    async function inflateRaw(data) {
      if (typeof DecompressionStream === "undefined") {
        throw new Error("Seu navegador n\u00e3o suporta descompactar DOCX.");
      }
      const ds = new DecompressionStream("deflate-raw");
      const stream = new Blob([data]).stream().pipeThrough(ds);
      return await new Response(stream).arrayBuffer();
    }

    async function readZipEntry(buffer, entryName) {
      const view = new DataView(buffer);
      const eocdOffset = findZipEocdOffset(view);
      if (eocdOffset < 0) throw new Error("Arquivo DOCX inv\u00e1lido (EOCD).");

      const totalEntries = view.getUint16(eocdOffset + 10, true);
      const cdOffset = view.getUint32(eocdOffset + 16, true);
      const decoder = new TextDecoder("utf-8");

      let ptr = cdOffset;
      let entry = null;
      for (let i = 0; i < totalEntries; i++) {
        if (view.getUint32(ptr, true) !== 0x02014b50) break;
        const compMethod = view.getUint16(ptr + 10, true);
        const compSize = view.getUint32(ptr + 20, true);
        const uncompSize = view.getUint32(ptr + 24, true);
        const nameLen = view.getUint16(ptr + 28, true);
        const extraLen = view.getUint16(ptr + 30, true);
        const commentLen = view.getUint16(ptr + 32, true);
        const localOffset = view.getUint32(ptr + 42, true);
        const nameBytes = new Uint8Array(buffer, ptr + 46, nameLen);
        const name = decoder.decode(nameBytes);
        if (name === entryName) {
          entry = { compMethod, compSize, uncompSize, localOffset };
          break;
        }
        ptr += 46 + nameLen + extraLen + commentLen;
      }

      if (!entry) throw new Error(`Entrada n\u00e3o encontrada no DOCX: ${entryName}`);

      if (view.getUint32(entry.localOffset, true) !== 0x04034b50) {
        throw new Error("Cabe\u00e7alho ZIP inv\u00e1lido.");
      }
      const localNameLen = view.getUint16(entry.localOffset + 26, true);
      const localExtraLen = view.getUint16(entry.localOffset + 28, true);
      const dataStart = entry.localOffset + 30 + localNameLen + localExtraLen;
      const compData = buffer.slice(dataStart, dataStart + entry.compSize);

      if (entry.compMethod === 0) return compData;
      if (entry.compMethod === 8) return await inflateRaw(compData);
      throw new Error(`Compress\u00e3o ZIP n\u00e3o suportada: ${entry.compMethod}`);
    }

    async function extractDocxDocumentXml(buffer) {
      const xmlBuffer = await readZipEntry(buffer, "word/document.xml");
      return new TextDecoder("utf-8").decode(xmlBuffer);
    }

    function extractParagraphLines(paragraph) {
      const lines = [""];
      const addText = (t) => { lines[lines.length - 1] += t; };
      const walk = (node) => {
        if (node.nodeType !== 1) return;
        if (node.namespaceURI && node.namespaceURI !== WORD_NS) return;
        const name = node.localName;
        if (name === "drawing" || name === "pict" || name === "object") return;
        if (name === "br" || name === "cr") {
          lines.push("");
          return;
        }
        if (name === "tab") {
          addText("\t");
          return;
        }
        if (name === "t") {
          addText(node.textContent || "");
          return;
        }
        for (const child of node.childNodes) walk(child);
      };
      walk(paragraph);
      return lines.map(l => normalizeSpaces(l)).filter(Boolean);
    }

    function extractDocxTextLines(docXml) {
      const doc = new DOMParser().parseFromString(docXml, "application/xml");
      if (doc.getElementsByTagName("parsererror").length) return [];
      let paragraphs = Array.from(doc.getElementsByTagNameNS(WORD_NS, "p"));
      if (!paragraphs.length) paragraphs = Array.from(doc.getElementsByTagName("w:p"));
      if (!paragraphs.length) paragraphs = Array.from(doc.getElementsByTagName("p"));
      const lines = [];
      for (const p of paragraphs) {
        const pLines = extractParagraphLines(p);
        if (pLines.length) lines.push(...pLines);
      }
      return lines;
    }

    function parseDocxTimeToSeconds(ts) {
      const parts = String(ts || "").split(":").map(p => Number(p));
      if (parts.some(n => !Number.isFinite(n))) return null;
      if (parts.length === 2) return (parts[0] * 60) + parts[1];
      if (parts.length === 3) return (parts[0] * 3600) + (parts[1] * 60) + parts[2];
      return null;
    }

    function parseDocxLines(lines) {
      const cleaned = (lines || []).map(l => normalizeSpaces(l)).filter(Boolean);
      if (!cleaned.length) return null;
      const joined = cleaned.join(" ");
      if (/come\u00e7ou a transcri/i.test(joined) || /parou a transcri/i.test(joined)) return null;

      const timeOnly = /^\d{1,2}:\d{2}(?::\d{2})?$/;
      let speaker = "";
      let timeStr = "";
      let textParts = [];

      const first = cleaned[0];
      const match = first.match(/^(.*?)[\s]+(\d{1,2}:\d{2}(?::\d{2})?)(?:\s+(.*))?$/);
      if (match) {
        speaker = match[1];
        timeStr = match[2];
        if (match[3]) textParts.push(match[3]);
        textParts = textParts.concat(cleaned.slice(1));
      } else if (cleaned.length >= 2 && timeOnly.test(cleaned[1])) {
        speaker = cleaned[0];
        timeStr = cleaned[1];
        textParts = cleaned.slice(2);
      } else {
        return null;
      }

      speaker = String(speaker).replace(/[:\uFF1A]\s*$/, "").trim();
      const text = normalizeSpaces(textParts.join(" "));
      if (!speaker || !text) return null;
      const startS = parseDocxTimeToSeconds(timeStr);
      if (!Number.isFinite(startS)) return null;

      return { speaker, text, startS, timeStr };
    }

    function parseDocxSegmentsFromLines(lines) {
      const segments = [];
      const timeOnly = /^\d{1,2}:\d{2}(?::\d{2})?$/;
      const isSystemLine = (line) => /come\u00e7ou a transcri/i.test(line) || /parou a transcri/i.test(line);
      let i = 0;

      while (i < lines.length) {
        const maybeSpeaker = lines[i];
        const maybeTime = lines[i + 1];
        let speaker = "";
        let timeStr = "";
        if (maybeSpeaker) {
          const inline = maybeSpeaker.match(/^(.*?)[\s]+(\d{1,2}:\d{2}(?::\d{2})?)$/);
          if (inline) {
            speaker = inline[1];
            timeStr = inline[2];
            i += 1;
          } else if (maybeTime && timeOnly.test(maybeTime)) {
            speaker = maybeSpeaker;
            timeStr = maybeTime;
            i += 2;
          }
        }

        if (speaker && timeStr) {
          speaker = String(speaker).replace(/[:\uFF1A]\s*$/, "").trim();
          const startS = parseDocxTimeToSeconds(timeStr);
          const textParts = [];
          while (i < lines.length) {
            const lookSpeaker = lines[i];
            const lookTime = lines[i + 1];
            if (lookSpeaker && lookTime && timeOnly.test(lookTime)) break;
            if (lookSpeaker && !isSystemLine(lookSpeaker)) textParts.push(lookSpeaker);
            i++;
          }
          const text = normalizeSpaces(textParts.join(" "));
          if (speaker && text && Number.isFinite(startS)) {
            segments.push({ speaker, text, startS, timeStr });
          }
          continue;
        }
        i++;
      }

      return segments;
    }

    function parseDocxSegments(docXml) {
      const doc = new DOMParser().parseFromString(docXml, "application/xml");
      if (doc.getElementsByTagName("parsererror").length) {
        throw new Error("Falha ao interpretar XML do DOCX.");
      }
      let paragraphs = Array.from(doc.getElementsByTagNameNS(WORD_NS, "p"));
      if (!paragraphs.length) paragraphs = Array.from(doc.getElementsByTagName("w:p"));
      if (!paragraphs.length) paragraphs = Array.from(doc.getElementsByTagName("p"));
      logDebug("DOCX par\u00e1grafos encontrados", { count: paragraphs.length });
      const segments = [];

      for (const p of paragraphs) {
        const lines = extractParagraphLines(p);
        if (!lines.length) continue;
        const seg = parseDocxLines(lines);
        if (!seg) continue;
        segments.push(seg);
      }

      if (segments.length) {
        logDebug("DOCX segmentos exemplo", segments.slice(0, 3));
      }

      if (!segments.length) {
        const fallbackLines = extractDocxTextLines(docXml);
        logDebug("DOCX fallback linhas (amostra)", fallbackLines.slice(0, 8));
        const fallbackSegments = parseDocxSegmentsFromLines(fallbackLines);
        if (fallbackSegments.length) {
          logDebug("DOCX fallback parser ativo", { lines: fallbackLines.length, segments: fallbackSegments.length });
          const cleanLines = fallbackSegments.map(s => `${s.speaker}>${s.text}`);
          return { segments: fallbackSegments, cleanText: cleanLines.join("\n") };
        }
      }

      const cleanLines = segments.map(s => `${s.speaker}>${s.text}`);
      return { segments, cleanText: cleanLines.join("\n") };
    }

    function estimateDurationSeconds(text) {
      const chars = countSpeechChars(text);
      return chars * DEFAULT_SECONDS_PER_CHAR;
    }

    function buildDocxCuesFromSegments(segments) {
      const cues = [];
      for (let i = 0; i < segments.length; i++) {
        const seg = segments[i];
        if (!Number.isFinite(seg.startS)) continue;
        const next = segments[i + 1];
        const nextStart = next && Number.isFinite(next.startS) ? next.startS : null;
        const gap = (Number.isFinite(nextStart) && nextStart > seg.startS) ? (nextStart - seg.startS) : null;
        let dur = estimateDurationSeconds(seg.text);
        dur = Math.max(MIN_ESTIMATED_SECONDS, dur || 0);
        if (Number.isFinite(gap) && gap > 0) {
          dur = Math.min(dur, gap);
        }
        const endS = seg.startS + dur;
        cues.push({
          startS: seg.startS,
          endS,
          speakers: [{ name: seg.speaker, text: seg.text }],
        });
      }
      return cues;
    }

    function parseVtt(raw) {
      const joinInternal = true;
      const doTrim = true;
      const removeTags = true;
      const dropEmpty = true;

      const text = (raw || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      const blocks = text.split(/\n\s*\n+/g);

      const cleanLines = [];
      const cues = []; // {startS, endS, speakers: [{name, text}]}

      for (const block of blocks) {
        const lines = block.split("\n").map(l => l.trimEnd());
        if (!lines.length) continue;

        if (lines[0].trim() === "WEBVTT") continue;
        const first = lines[0].trim();
        if (/^(NOTE|STYLE|REGION)\b/i.test(first)) continue;

        let i = 0;
        if (lines[i] && !isTimestampLine(lines[i]) && !/^\d{2}:\d{2}:\d{2}/.test(lines[i]) && !/<v\s+/i.test(lines[i])) {
          i++;
        }

        if (!lines[i] || !isTimestampLine(lines[i])) {
          const payloadFallback = lines.slice(i).filter(l => l.trim().length > 0);
          if (!payloadFallback.length) continue;
          let line = joinInternal ? payloadFallback.join(" ") : payloadFallback.join("\n");
          if (removeTags) line = stripAllTags(line);
          if (doTrim) line = normalizeSpaces(line);
          if (!line && dropEmpty) continue;
          cleanLines.push(line);
          continue;
        }

        const tsLine = lines[i].trim();
        i++;
        const tm = tsLine.match(/(\d{2}:\d{2}:\d{2}(?:\.\d+)?)\s*-->\s*(\d{2}:\d{2}:\d{2}(?:\.\d+)?)/);
        const startS = tm ? parseTimeToSeconds(tm[1]) : null;
        const endS = tm ? parseTimeToSeconds(tm[2]) : null;

        const payload = lines.slice(i).filter(l => l.trim().length > 0);
        if (!payload.length) continue;
        const payloadText = joinInternal ? payload.join(" ") : payload.join("\n");

        const segs = [];
        const re = /<v\s+([^>]+)>([\s\S]*?)<\/v>/gi;
        let match;
        while ((match = re.exec(payloadText)) !== null) {
          const speaker = (match[1] || "").trim();
          let content = match[2] || "";
          if (removeTags) content = stripAllTags(content);
          if (doTrim) content = normalizeSpaces(content);
          if (!content && dropEmpty) continue;
          segs.push({ name: speaker, text: content });
          cleanLines.push(`${speaker}>${content}`);
        }

        if (segs.length) {
          if (Number.isFinite(startS) && Number.isFinite(endS) && endS >= startS) {
            cues.push({ startS, endS, speakers: segs });
          }
          continue;
        }

        // Suporte a <v Nome> sem tag de fechamento (comum em VTT)
        const looseSegs = [];
        const tagRe = /<v\s+([^>]+)>/gi;
        let lastIndex = 0;
        let lastName = null;
        let tag;
        while ((tag = tagRe.exec(payloadText)) !== null) {
          if (lastName !== null) {
            let content = payloadText.slice(lastIndex, tag.index);
            if (removeTags) content = stripAllTags(content);
            if (doTrim) content = normalizeSpaces(content);
            if (content || !dropEmpty) {
              looseSegs.push({ name: lastName, text: content });
              if (content) cleanLines.push(`${lastName}>${content}`);
            }
          }
          lastName = (tag[1] || "").trim();
          lastIndex = tagRe.lastIndex;
        }
        if (lastName !== null) {
          let content = payloadText.slice(lastIndex);
          if (removeTags) content = stripAllTags(content);
          if (doTrim) content = normalizeSpaces(content);
          if (content || !dropEmpty) {
            looseSegs.push({ name: lastName, text: content });
            if (content) cleanLines.push(`${lastName}>${content}`);
          }
        }

        if (looseSegs.length) {
          if (Number.isFinite(startS) && Number.isFinite(endS) && endS >= startS) {
            cues.push({ startS, endS, speakers: looseSegs });
          }
          continue;
        }

        let line = payloadText;
        if (removeTags) line = stripAllTags(line);
        if (doTrim) line = normalizeSpaces(line);
        if (!line && dropEmpty) continue;

        const m2 = line.match(/^(.{2,80}?)[\uFF1A:]\s*(.+)$/);
        if (m2) {
          const speaker = doTrim ? normalizeSpaces(m2[1]) : m2[1].trim();
          const content = doTrim ? normalizeSpaces(m2[2]) : m2[2].trim();
          if (!content && dropEmpty) continue;
          cleanLines.push(`${speaker}>${content}`);
          if (Number.isFinite(startS) && Number.isFinite(endS) && endS >= startS) {
            cues.push({ startS, endS, speakers: [{ name: speaker, text: content }] });
          }
        } else {
          cleanLines.push(line);
        }
      }

      return { cleanText: cleanLines.join("\n"), cues };
    }

    function computeStats(cues) {
      let minS = Infinity;
      let maxE = -Infinity;
      const personSeconds = new Map();
      const personTurns = new Map();
      const presence = new Set();

      for (const cue of cues) {
        if (!Number.isFinite(cue.startS) || !Number.isFinite(cue.endS)) continue;
        minS = Math.min(minS, cue.startS);
        maxE = Math.max(maxE, cue.endS);

        const dur = Math.max(0, cue.endS - cue.startS);
        const speakers = cue.speakers || [];
        if (!speakers.length) continue;

        const uniqueNames = Array.from(new Set(speakers.map(s => s.name).filter(Boolean)));
        uniqueNames.forEach(n => presence.add(n));

        const share = uniqueNames.length ? dur / uniqueNames.length : 0;
        for (const name of uniqueNames) {
          personSeconds.set(name, (personSeconds.get(name) || 0) + share);
        }
        for (const name of uniqueNames) {
          personTurns.set(name, (personTurns.get(name) || 0) + 1);
        }
      }

      const totalMeeting = (minS !== Infinity && maxE !== -Infinity) ? Math.max(0, maxE - minS) : 0;
      let totalSpeech = 0;
      for (const v of personSeconds.values()) totalSpeech += v;

      let totalTurns = 0;
      for (const v of personTurns.values()) totalTurns += v;

      const names = new Set([...personSeconds.keys(), ...personTurns.keys()]);
      const rows = Array.from(names)
        .map((name) => ({ name, seconds: personSeconds.get(name) || 0, turns: personTurns.get(name) || 0 }))
        .sort((a, b) => b.seconds - a.seconds);

      for (const r of rows) {
        r.pct = totalSpeech > 0 ? (r.seconds / totalSpeech) * 100 : 0;
        r.turnPct = totalTurns > 0 ? (r.turns / totalTurns) * 100 : 0;
      }

      const turnRows = Array.from(names)
        .map((name) => ({ name, turns: personTurns.get(name) || 0 }))
        .sort((a, b) => b.turns - a.turns);

      for (const r of turnRows) {
        r.turnPct = totalTurns > 0 ? (r.turns / totalTurns) * 100 : 0;
      }

      return {
        totalMeeting,
        totalSpeech,
        totalTurns,
        presence: Array.from(presence).sort((a, b) => a.localeCompare(b, undefined)),
        rows,
        turnRows,
      };
    }

    function getMeetingTitleParts() {
      const typed = (meetingTitleEl.value || "").trim();
      const inferred = (meetingTitleEl.getAttribute("data-inferred") || "").trim();
      const title = typed || inferred || "(sem t\u00edtulo)";
      const notes = (meetingNotesEl.value || "").trim();
      return { title, notes };
    }

    function updateTitlePill() {
      const { title, notes } = getMeetingTitleParts();
      const sep = " \u2022 ";
      pillTitle.textContent = notes ? `T\u00edtulo: ${title}${sep}${notes}` : `T\u00edtulo: ${title}`;
    }

    function updateSummaryPills(stats) {
      if (!lastProcessed) {
        pillTotal.textContent = `Dura\u00e7\u00e3o total: ${EMPTY_METRICS_TEXT}`;
        pillPeople.textContent = `Participantes: ${EMPTY_METRICS_TEXT}`;
        pillTotalSticky.textContent = `Dura\u00e7\u00e3o total: ${EMPTY_METRICS_TEXT}`;
        pillPeopleSticky.textContent = `Participantes: ${EMPTY_METRICS_TEXT}`;
        return;
      }
      pillTotal.textContent = `Dura\u00e7\u00e3o total: ${formatDuration(stats.totalMeeting)}`;
      pillPeople.textContent = `Participantes: ${stats.presence.length}`;
      pillTotalSticky.textContent = `Dura\u00e7\u00e3o total: ${formatDuration(stats.totalMeeting)}`;
      pillPeopleSticky.textContent = `Participantes: ${stats.presence.length}`;
    }

    function renderEmptyRow(tbody, colSpan) {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td colspan="${colSpan}" class="emptyState">${EMPTY_METRICS_TEXT}</td>`;
      tbody.appendChild(tr);
    }

    function renderStats(stats) {
      updateSummaryPills(stats);
      statsBody.innerHTML = "";
      if (!lastProcessed || !stats.rows.length) {
        renderEmptyRow(statsBody, 4);
        return;
      }

      const maxPct = Math.max(...stats.rows.map(r => r.pct));

      for (const r of stats.rows) {
        const tr = document.createElement("tr");
        const pctStr = `${r.pct.toFixed(1)}%`;
        const w = maxPct > 0 ? (r.pct / maxPct) * 100 : 0;
        tr.innerHTML = `
          <td><strong>${escapeHtml(r.name)}</strong></td>
          <td>${formatDuration(r.seconds)}</td>
          <td>${pctStr}</td>
          <td><div class="bar" title="${pctStr}"><div style="width:${w.toFixed(1)}%"></div></div></td>
        `;
        statsBody.appendChild(tr);
      }
    }

    function renderTurns(stats) {
      turnsBody.innerHTML = "";
      turnsMeta.textContent = (lastProcessed && stats.totalTurns) ? `${stats.totalTurns} turno(s)` : EMPTY_METRICS_TEXT;

      if (!lastProcessed || !stats.turnRows || !stats.turnRows.length) {
        renderEmptyRow(turnsBody, 4);
        return;
      }

      const maxPct = Math.max(...stats.turnRows.map(r => r.turnPct));

      for (const r of stats.turnRows) {
        const tr = document.createElement("tr");
        const pctStr = `${r.turnPct.toFixed(1)}%`;
        const w = maxPct > 0 ? (r.turnPct / maxPct) * 100 : 0;
        tr.innerHTML = `
          <td><strong>${escapeHtml(r.name)}</strong></td>
          <td>${r.turns}</td>
          <td>${pctStr}</td>
          <td><div class="bar" title="${pctStr}"><div style="width:${w.toFixed(1)}%"></div></div></td>
        `;
        turnsBody.appendChild(tr);
      }
    }

    function renderWordCloud(cues, cleanText) {
      wordCloud.innerHTML = "";
      if (!lastProcessed) {
        wordCloud.classList.add("chartEmpty");
        wordCloud.textContent = EMPTY_METRICS_TEXT;
        wordCloudMeta.textContent = EMPTY_METRICS_TEXT;
        return;
      }
      const data = computeWordCloudData(cues, cleanText);
      if (!data.words.length) {
        wordCloud.classList.add("chartEmpty");
        wordCloud.textContent = EMPTY_METRICS_TEXT;
        wordCloudMeta.textContent = EMPTY_METRICS_TEXT;
        return;
      }
      wordCloud.classList.remove("chartEmpty");

      const sorted = data.words.slice().sort((a, b) => b.count - a.count);
      const max = sorted[0].count;
      const min = sorted[sorted.length - 1].count;

      const rect = wordCloud.getBoundingClientRect();
      const width = rect.width || wordCloud.clientWidth || 1;
      const height = rect.height || wordCloud.clientHeight || 1;
      const center = { x: width / 2, y: height / 2 };
      const aspect = width / height;
      const placed = [];
      const step = 1.6;
      const maxAttempts = 8000;
      const maxRadius = Math.max(width, height) * 1.15;

      const overlaps = (a, b) => {
        return Math.abs(2 * a.left + a.width - 2 * b.left - b.width) < a.width + b.width
          && Math.abs(2 * a.top + a.height - 2 * b.top - b.height) < a.height + b.height;
      };

      const hitsAny = (rect) => {
        for (const p of placed) {
          if (overlaps(rect, p)) return true;
        }
        return false;
      };

      const getWeightClass = (count) => {
        if (max <= min) return 5;
        return Math.round((count - min) / (max - min) * 9) + 1;
      };

      const colorFor = (idx, total) => {
        if (total <= 1) return "hsl(20, 80%, 45%)";
        const t = idx / (total - 1);
        const hue = 20 + t * 200;
        return `hsl(${hue.toFixed(0)}, 80%, 45%)`;
      };

      sorted.forEach((item, index) => {
        const span = document.createElement("span");
        span.textContent = item.word;
        span.title = `${item.word} (${item.count})`;
        span.style.color = colorFor(index, sorted.length);
        wordCloud.appendChild(span);

        let weight = getWeightClass(item.count);
        let placedOk = false;

        while (weight >= 1 && !placedOk) {
          span.className = `w${weight}`;
          const w = span.offsetWidth;
          const h = span.offsetHeight;
          let left = center.x - w / 2;
          let top = center.y - h / 2;
          span.style.position = "absolute";
          span.style.left = `${left}px`;
          span.style.top = `${top}px`;

          let angle = Math.random() * 6.28;
          let radius = 0;
          let attempts = 0;

          while (attempts < maxAttempts) {
            const rectNow = { left, top, width: w, height: h };
            if (!hitsAny(rectNow)) {
              placedOk = true;
              break;
            }
            radius += step;
            angle += (index % 2 === 0 ? 1 : -1) * step;
            left = center.x - (w / 2) + (radius * Math.cos(angle)) * aspect;
            top = center.y + (radius * Math.sin(angle)) - (h / 2);
            attempts++;
            if (radius > maxRadius) break;
          }

          if (!placedOk || left < 0 || top < 0 || (left + w) > width || (top + h) > height) {
            placedOk = false;
            weight -= 1;
            continue;
          }

          span.style.left = `${left}px`;
          span.style.top = `${top}px`;
          placed.push({ left, top, width: w, height: h });
        }

        if (!placedOk) {
          span.remove();
        }
      });

      const topLabel = data.words.length === data.limit ? `Top ${data.limit}` : `Top ${data.words.length}`;
      wordCloudMeta.textContent = `${topLabel} \u2022 ${data.uniqueCount} \u00fanicas`;
    }

    function renderTimeline(cues, stats) {
      timelineChart.classList.add("chartEmpty");
      timelineChart.innerHTML = EMPTY_METRICS_TEXT;
      timelineLegend.innerHTML = "";
      timelineMeta.textContent = EMPTY_METRICS_TEXT;
      timelineStart.textContent = "In\u00edcio";
      timelineEnd.textContent = "Fim";

      if (!lastProcessed || !cues || !cues.length || !stats || !Number.isFinite(stats.totalMeeting) || stats.totalMeeting <= 0) {
        return;
      }

      const bucketSeconds = pickBucketSeconds(stats.totalMeeting);
      const orderDesc = (stats.rows || []).map(r => r.name);
      const timeline = computeTimeline(cues, orderDesc, bucketSeconds);
      if (!timeline || timeline.maxBucketSeconds <= 0) {
        return;
      }

      const colorMap = new Map();
      timeline.order.forEach((name, idx) => {
        colorMap.set(name, speakerColors[idx % speakerColors.length]);
      });

      timelineChart.classList.remove("chartEmpty");
      timelineChart.innerHTML = "";

      const orderAsc = Array.from(timeline.order).reverse();
      for (let i = 0; i < timeline.bucketCount; i++) {
        const bar = document.createElement("div");
        bar.className = "chartBar";
        const bucketStart = i * timeline.bucketSeconds;
        const bucketEnd = Math.min((i + 1) * timeline.bucketSeconds, stats.totalMeeting);
        bar.title = `${formatDuration(bucketStart)} \u2192 ${formatDuration(bucketEnd)}`;

        for (const name of orderAsc) {
          const arr = timeline.buckets.get(name);
          const secs = arr ? arr[i] : 0;
          if (!secs) continue;
          const seg = document.createElement("div");
          seg.className = "chartSeg";
          const h = (secs / timeline.maxBucketSeconds) * 100;
          seg.style.height = `${h.toFixed(2)}%`;
          seg.style.background = colorMap.get(name);
          seg.title = `${name}: ${formatDuration(secs)}`;
          bar.appendChild(seg);
        }
        timelineChart.appendChild(bar);
      }

      const maxMinutes = timeline.maxBucketSeconds / 60;
      timelineMeta.textContent = `Resolu\u00e7\u00e3o: ${formatBucketLabel(bucketSeconds)} \u2022 Pico: ${maxMinutes.toFixed(1)} min`;
      timelineStart.textContent = "0:00";
      timelineEnd.textContent = formatDuration(stats.totalMeeting);

      for (const name of timeline.order) {
        const item = document.createElement("div");
        item.className = "legendItem";
        const swatch = document.createElement("span");
        swatch.className = "legendSwatch";
        swatch.style.background = colorMap.get(name);
        const label = document.createElement("span");
        label.textContent = name;
        item.appendChild(swatch);
        item.appendChild(label);
        timelineLegend.appendChild(item);
      }
    }

    function padRight(s, n) {
      s = String(s);
      return s.length >= n ? s : s + " ".repeat(n - s.length);
    }

    function buildPlainTextTable(stats) {
      const rows = stats.rows || [];
      const header1 = "Participante";
      const header2 = "Tempo";
      const header3 = "% fala";

      const nameW = Math.min(40, Math.max(header1.length, ...rows.map(r => String(r.name).length)));
      const timeW = Math.max(header2.length, ...rows.map(r => formatDuration(r.seconds).length));
      const pctW = Math.max(header3.length, ...rows.map(r => `${r.pct.toFixed(1)}%`.length));

      const lines = [];
      lines.push(`${padRight(header1, nameW)}  ${padRight(header2, timeW)}  ${padRight(header3, pctW)}`);
      lines.push(`${"-".repeat(nameW)}  ${"-".repeat(timeW)}  ${"-".repeat(pctW)}`);

      for (const r of rows) {
        const pct = `${r.pct.toFixed(1)}%`;
        lines.push(`${padRight(r.name, nameW)}  ${padRight(formatDuration(r.seconds), timeW)}  ${padRight(pct, pctW)}`);
      }
      return lines.join("\n");
    }

    function buildPlainTextTurnsTable(stats) {
      const rows = stats.turnRows || [];
      const header1 = "Participante";
      const header2 = "Turnos";
      const header3 = "% turnos";

      const nameW = Math.min(40, Math.max(header1.length, ...rows.map(r => String(r.name).length)));
      const turnsW = Math.max(header2.length, ...rows.map(r => String(r.turns).length));
      const pctW = Math.max(header3.length, ...rows.map(r => `${r.turnPct.toFixed(1)}%`.length));

      const lines = [];
      lines.push(`${padRight(header1, nameW)}  ${padRight(header2, turnsW)}  ${padRight(header3, pctW)}`);
      lines.push(`${"-".repeat(nameW)}  ${"-".repeat(turnsW)}  ${"-".repeat(pctW)}`);

      for (const r of rows) {
        const pct = `${r.turnPct.toFixed(1)}%`;
        lines.push(`${padRight(r.name, nameW)}  ${padRight(r.turns, turnsW)}  ${padRight(pct, pctW)}`);
      }
      return lines.join("\n");
    }

    function buildPlainTextSummary(stats) {
      const { title, notes } = getMeetingTitleParts();
      const startDT = buildMeetingDateTime();
      const startStr = startDT ? formatLocalDateTime(startDT) : "\u2014";

      const participants = (stats.presence || []).join(", ") || "\u2014";
      const totalMeetingStr = formatDuration(stats.totalMeeting);
      const totalSpeechStr = formatDuration(stats.totalSpeech);

      const lines = [];
      lines.push(`T\u00edtulo: ${title}`);
      if (notes) lines.push(`Observa\u00e7\u00f5es: ${notes}`);
      lines.push(`In\u00edcio: ${startStr}`);
      lines.push(`Participantes (${(stats.presence || []).length}): ${participants}`);
      lines.push(`Tempo total da reuni\u00e3o: ${totalMeetingStr}`);
      lines.push(`Tempo total de fala (estimado): ${totalSpeechStr}`);
      lines.push(`Total de turnos: ${stats.totalTurns || 0}`);
      lines.push("");
      lines.push("Fala por participante:");
      lines.push(buildPlainTextTable(stats));
      lines.push("");
      lines.push("Turnos por participante:");
      lines.push(buildPlainTextTurnsTable(stats));
      return lines.join("\n");
    }

    function buildFinalOutput(transcriptCleanText, stats) {
      const summary = buildPlainTextSummary(stats);
      const transcript = (transcriptCleanText || "").trim();
      return transcript ? `${summary}\n\nTranscri\u00e7\u00e3o:\n${transcript}\n` : `${summary}\n`;
    }

    async function readFileAsText(file) {
      return await file.text();
    }

    function applyInferredTitle(filename) {
      const inferred = inferTitleFromFilename(filename);
      meetingTitleEl.setAttribute("data-inferred", inferred);
      updateTitlePill();
    }

    function setDropMeta(filename = "") {
      if (!dropMeta) return;
      dropMeta.textContent = filename ? `Selecionado: ${filename}` : "Nenhum arquivo selecionado";
    }

    function setDropActive(active) {
      if (dropzone) dropzone.classList.toggle("dragover", active);
      if (configCard) configCard.classList.toggle("dragover", active);
    }

    async function handleSelectedFile(f) {
      if (!f) return;
      try {
        const lower = f.name.toLowerCase();
        applyInferredTitle(f.name);
        if (lower.endsWith(".docx")) {
          activeSource = "docx";
          setStatus(`Lendo DOCX: ${f.name}...`, "muted");
          const buffer = await f.arrayBuffer();
          logDebug("DOCX carregando", { name: f.name, size: f.size });
          const docXml = await extractDocxDocumentXml(buffer);
          logDebug("DOCX XML extra\u00eddo", { chars: docXml.length });
          const parsed = parseDocxSegments(docXml);
          logDebug("DOCX parse conclu\u00eddo", { segments: parsed.segments.length, lines: parsed.cleanText.split("\n").filter(Boolean).length });
          lastDocx = parsed;
          inputEl.value = parsed.cleanText || "";
          setStatus(`DOCX carregado: ${f.name} (${parsed.segments.length} fala(s))`, "success");
        } else {
          activeSource = "vtt";
          lastDocx = null;
          setStatus(`Lendo: ${f.name}...`, "muted");
          const content = await readFileAsText(f);
          inputEl.value = content;
          setStatus(`Arquivo carregado: ${f.name}`, "success");
        }
      } catch (e) {
        console.error(e);
        setStatus(e && e.message ? e.message : "Falha ao ler o arquivo.", "warn");
      }
    }

    fileEl.addEventListener("change", async () => {
      const f = fileEl.files && fileEl.files[0];
      if (!f) return;
      setDropMeta(f.name);
      await handleSelectedFile(f);
    });

    if (pickFile) {
      pickFile.addEventListener("click", (event) => {
        event.stopPropagation();
        fileEl.click();
      });
    }

    if (dropzone) {
      dropzone.addEventListener("click", () => fileEl.click());
      dropzone.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          fileEl.click();
        }
      });
    }

    if (configCard) {
      const onDragOver = (event) => {
        event.preventDefault();
        setDropActive(true);
      };
      const onDragLeave = (event) => {
        if (event.currentTarget.contains(event.relatedTarget)) return;
        setDropActive(false);
      };
      const onDrop = async (event) => {
        event.preventDefault();
        setDropActive(false);
        const f = event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files[0];
        if (!f) return;
        setDropMeta(f.name);
        await handleSelectedFile(f);
      };
      configCard.addEventListener("dragenter", onDragOver);
      configCard.addEventListener("dragover", onDragOver);
      configCard.addEventListener("dragleave", onDragLeave);
      configCard.addEventListener("drop", onDrop);
    }

    meetingTitleEl.addEventListener("input", () => {
      updateTitlePill();
      refreshOutputIfReady();
    });
    meetingNotesEl.addEventListener("input", () => {
      updateTitlePill();
      refreshOutputIfReady();
    });

    inputEl.addEventListener("input", () => {
      activeSource = "vtt";
    });

    let activeSource = "vtt";
    let lastDocx = null;

    let lastStats = { totalMeeting: 0, totalSpeech: 0, totalTurns: 0, presence: [], rows: [], turnRows: [] };
    let lastCues = [];
    let lastCleanText = "";
    let lastProcessed = false;

    function refreshOutputIfReady() {
      if (!lastProcessed) return;
      outputEl.value = buildFinalOutput(lastCleanText, lastStats);
    }

    function reprocessFromInput(options = {}) {
      activeSource = "vtt";
      const raw = inputEl.value || "";
      if (!raw.trim()) {
        if (!options.silent) {
          setStatus("Nenhuma entrada para processar.", "warn");
        }
        outputEl.value = "";
        setOutStatus("\u2014", "muted");
        lastStats = { totalMeeting: 0, totalSpeech: 0, totalTurns: 0, presence: [], rows: [], turnRows: [] };
        lastCues = [];
        lastCleanText = "";
        lastProcessed = false;
        renderStats(lastStats);
        renderTurns(lastStats);
        renderWordCloud(lastCues, lastCleanText);
        renderTimeline(lastCues, lastStats);
        updateTitlePill();
        return false;
      }
      try {
        const parsed = parseVtt(raw);
        lastStats = computeStats(parsed.cues);
        lastCues = parsed.cues || [];
        lastCleanText = parsed.cleanText || "";
        lastProcessed = true;
        renderStats(lastStats);
        renderTurns(lastStats);
        renderWordCloud(lastCues, lastCleanText);
        renderTimeline(lastCues, lastStats);
        updateTitlePill();
        outputEl.value = buildFinalOutput(lastCleanText, lastStats);
        const count = lastCleanText ? lastCleanText.split("\n").filter(Boolean).length : 0;
        if (!options.silent) {
          setStatus("Processado.", "success");
        }
        setOutStatus(`${count} linha(s) na transcri\u00e7\u00e3o`, "success");
        return true;
      } catch (e) {
        console.error(e);
        if (!options.silent) {
          setStatus("Erro ao processar.", "warn");
        }
        return false;
      }
    }

    function reprocessFromDocx(options = {}) {
      activeSource = "docx";
      if (!lastDocx || !lastDocx.segments || !lastDocx.segments.length) {
        if (!options.silent) {
          setStatus("Nenhum DOCX carregado.", "warn");
        }
        logDebug("DOCX sem segmentos para processar", { hasDocx: !!lastDocx, segments: lastDocx && lastDocx.segments ? lastDocx.segments.length : 0 });
        outputEl.value = "";
        setOutStatus("\u2014", "muted");
        lastStats = { totalMeeting: 0, totalSpeech: 0, totalTurns: 0, presence: [], rows: [], turnRows: [] };
        lastCues = [];
        lastCleanText = "";
        lastProcessed = false;
        renderStats(lastStats);
        renderTurns(lastStats);
        renderWordCloud(lastCues, lastCleanText);
        renderTimeline(lastCues, lastStats);
        updateTitlePill();
        return false;
      }
      try {
        const cues = buildDocxCuesFromSegments(lastDocx.segments);
        lastStats = computeStats(cues);
        lastCues = cues;
        lastCleanText = lastDocx.cleanText || "";
        lastProcessed = true;
        renderStats(lastStats);
        renderTurns(lastStats);
        renderWordCloud(lastCues, lastCleanText);
        renderTimeline(lastCues, lastStats);
        updateTitlePill();
        outputEl.value = buildFinalOutput(lastCleanText, lastStats);
        const count = lastCleanText ? lastCleanText.split("\n").filter(Boolean).length : 0;
        if (!options.silent) {
          setStatus("Processado (DOCX).", "success");
        }
        setOutStatus(`${count} linha(s) na transcri\u00e7\u00e3o`, "success");
        return true;
      } catch (e) {
        console.error(e);
        if (!options.silent) {
          setStatus("Erro ao processar DOCX.", "warn");
        }
        return false;
      }
    }

    function reprocess(options = {}) {
      if (activeSource === "docx") {
        return reprocessFromDocx(options);
      }
      return reprocessFromInput(options);
    }

    meetingDateEl.addEventListener("input", () => {
      meetingDateEl.value = formatDateInput(meetingDateEl.value);
      renderStats(lastStats);
      renderTurns(lastStats);
      refreshOutputIfReady();
    });

    meetingStartEl.addEventListener("input", () => {
      meetingStartEl.value = formatTimeInput(meetingStartEl.value);
      renderStats(lastStats);
      renderTurns(lastStats);
      refreshOutputIfReady();
    });

    $("process").addEventListener("click", () => {
      reprocess({ silent: false });
    });

    $("clear").addEventListener("click", () => {
      inputEl.value = "";
      outputEl.value = "";
      fileEl.value = "";
      setDropMeta("");
      meetingTitleEl.value = "";
      meetingTitleEl.setAttribute("data-inferred", "");
      meetingNotesEl.value = "";
      updateTitlePill();
      setStatus("Pronto.", "muted");
      setOutStatus("\u2014", "muted");
      activeSource = "vtt";
      lastDocx = null;
      lastStats = { totalMeeting: 0, totalSpeech: 0, totalTurns: 0, presence: [], rows: [], turnRows: [] };
      lastCues = [];
      lastCleanText = "";
      lastProcessed = false;
      renderStats(lastStats);
      renderTurns(lastStats);
      renderWordCloud(lastCues, lastCleanText);
      renderTimeline(lastCues, lastStats);
    });

    $("copy").addEventListener("click", async () => {
      try {
        const text = outputEl.value || "";
        if (!text.trim()) {
          setOutStatus("Nada para copiar", "warn");
          return;
        }
        await navigator.clipboard.writeText(text);
        setOutStatus("Copiado", "success");
      } catch {
        outputEl.focus();
        outputEl.select();
        const ok = document.execCommand("copy");
        setOutStatus(ok ? "Copiado" : "N\u00e3o foi poss\u00edvel copiar", ok ? "success" : "warn");
      }
    });

    $("download").addEventListener("click", () => {
      const text = outputEl.value || "";
      if (!text.trim()) {
        setOutStatus("Nada para baixar", "warn");
        return;
      }
      const inferred = meetingTitleEl.getAttribute("data-inferred") || "";
      const title = (meetingTitleEl.value || inferred || "transcricao").trim();
      const safeTitle = title.replace(/[^\w\d\-\s]+/g, "").trim().replace(/\s+/g, "-").toLowerCase();
      const stamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, "-");
      const filename = `${safeTitle || "transcricao"}-limpa-${stamp}.txt`;

      const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      setOutStatus("Download iniciado", "success");
    });

    updateTitlePill();
    renderStats(lastStats);
    renderTurns(lastStats);
    renderWordCloud(lastCues, lastCleanText);
    renderTimeline(lastCues, lastStats);
  </script>
</body>
</html>
