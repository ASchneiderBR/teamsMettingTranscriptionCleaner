<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Limpador VTT → TXT + Métricas</title>
  <style>
    :root{
      color-scheme: light dark;
      --bg:#ffffff; --fg:#0b0f14; --muted: rgba(15, 23, 42, 0.72);
      --card: rgba(2, 6, 23, 0.04); --border: rgba(2, 6, 23, 0.16); --border2: rgba(2, 6, 23, 0.24);
      --btn: rgba(2, 6, 23, 0.06); --btnBorder: rgba(2, 6, 23, 0.18);
      --primary: rgba(37, 99, 235, 0.18); --primaryBorder: rgba(37, 99, 235, 0.45);
      --shadow: 0 8px 24px rgba(2, 6, 23, 0.08);
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --r: 16px;
    }
    @media (prefers-color-scheme: dark){
      :root{
        --bg:#0b0f14; --fg:#e5e7eb; --muted: rgba(229, 231, 235, 0.74);
        --card: rgba(255,255,255,0.06); --border: rgba(255,255,255,0.14); --border2: rgba(255,255,255,0.22);
        --btn: rgba(255,255,255,0.06); --btnBorder: rgba(255,255,255,0.16);
        --primary: rgba(96, 165, 250, 0.18); --primaryBorder: rgba(96, 165, 250, 0.45);
        --shadow: 0 10px 28px rgba(0,0,0,0.35);
      }
    }
    *{box-sizing:border-box}
    body{margin:0; padding:22px; font-family: var(--sans); line-height:1.35; background: var(--bg); color: var(--fg)}
    .wrap{max-width: 1120px; margin:0 auto}

    .top{display:flex; flex-wrap:wrap; gap:10px 14px; align-items:baseline; justify-content:space-between; margin-bottom:12px}
    h1{font-size:18px; margin:0; letter-spacing:0.2px}
    .sub{margin:0; font-size:13px; color:var(--muted)}

    .pill{display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid var(--border); background: rgba(127,127,127,0.06); font-size:12px; color: var(--muted); white-space:nowrap}
    .kbd{font-family: var(--mono); border:1px solid var(--border2); border-bottom-width:2px; padding:1px 6px; border-radius:9px; font-size:12px; opacity:0.95}

    .grid{display:grid; grid-template-columns: 1fr; gap:14px; margin-top:14px}
    @media (min-width: 980px){ .grid{grid-template-columns: 1.1fr 0.9fr;} }

    .card{border:1px solid var(--border); border-radius: var(--r); padding:14px; background: var(--card); box-shadow: var(--shadow)}
    .card h2{font-size:14px; margin:0 0 10px; opacity:0.95}

    .row{display:grid; grid-template-columns: 1fr; gap:10px}
    @media (min-width: 720px){
      .row.cols2{grid-template-columns: 1fr 1fr}
      .row.cols3{grid-template-columns: 1fr 1fr 1fr}
    }

    label{display:block; font-weight:800; font-size:12px; margin:0 0 6px; opacity:0.92}
    input[type=file], input[type=text], input[type=date], input[type=time]{
      width:100%; padding:10px 12px; border-radius:14px; border:1px solid var(--border2);
      background: transparent; color: var(--fg); outline:none;
    }

    textarea{
      width:100%; min-height:240px; padding:12px; border-radius:14px; border:1px solid var(--border2);
      background: transparent; color: var(--fg); outline:none;
      font-family: var(--mono); font-size:12.5px; resize: vertical;
    }

    .controls{display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-top:10px}
    button{border:1px solid var(--btnBorder); background: var(--btn); color: var(--fg); padding:10px 12px; border-radius:14px; cursor:pointer; font-weight:800}
    button.primary{background: var(--primary); border-color: var(--primaryBorder)}
    button:active{transform: translateY(1px)}
    .status{margin-left:auto; font-size:12px; color: var(--muted)}
    .hint{font-size:12px; color: var(--muted); margin-top:8px}

    .opts{display:grid; grid-template-columns:1fr; gap:8px; margin-top:10px; padding-top:10px; border-top:1px solid var(--border)}
    @media (min-width: 900px){ .opts{grid-template-columns:1fr 1fr;} }
    .opt{display:flex; gap:10px; align-items:flex-start; padding:10px 12px; border-radius:14px; border:1px solid var(--border); background: rgba(127,127,127,0.04)}
    .opt input{margin-top:3px}

    table{width:100%; border-collapse:separate; border-spacing:0; overflow:hidden; border-radius:14px; border:1px solid var(--border); margin-top:10px}
    th, td{padding:10px; border-bottom:1px solid var(--border); font-size:12.5px; text-align:left; vertical-align:top}
    th{font-size:12px; color: var(--muted); font-weight:900}
    tr:last-child td{border-bottom:none}

    .bar{height:10px; border-radius:999px; border:1px solid var(--border); background: rgba(127,127,127,0.08); overflow:hidden}
    .bar > div{height:100%; background: var(--primaryBorder); width:0%}

    .testBadge{margin-left:8px; font-family: var(--mono); font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid var(--border2); opacity:0.9}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div>
        <h1>Limpador de transcrição (.vtt) → TXT + métricas de fala <span class="testBadge" id="testBadge">tests: …</span></h1>
        <p class="sub">Gera linhas <span class="kbd">Nome&gt;Texto</span> e calcula tempo por participante com base em <span class="kbd">início → fim</span> de cada cue.</p>
      </div>
      <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
        <span class="pill" id="pillTitle">Título: —</span>
        <span class="pill" id="pillTotal">Duração total: —</span>
        <span class="pill" id="pillPeople">Participantes: —</span>
      </div>
    </div>

    <div class="card">
      <div class="row cols3">
        <div>
          <label for="file">Arquivo .vtt</label>
          <input id="file" type="file" accept=".vtt,text/vtt,text/plain" />
          <div class="hint">O título tenta ser extraído do nome do arquivo automaticamente.</div>
        </div>
        <div>
          <label for="meetingDate">Dia da reunião</label>
          <input id="meetingDate" type="date" />
        </div>
        <div>
          <label for="meetingStart">Horário de início</label>
          <input id="meetingStart" type="time" step="60" />
        </div>
      </div>
      <div class="row cols2" style="margin-top:10px;">
        <div>
          <label for="meetingTitle">Título da reunião (opcional)</label>
          <input id="meetingTitle" type="text" placeholder="(se vazio, usa o nome do arquivo)" />
        </div>
        <div>
          <label for="meetingNotes">Observações (opcional)</label>
          <input id="meetingNotes" type="text" placeholder="ex: Alinhamento comercial" />
        </div>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <h2>Entrada</h2>
        <label for="input">Cole aqui o conteúdo do VTT (ou carregue o arquivo acima)</label>
        <textarea id="input" placeholder="Cole aqui o conteúdo do .vtt..."></textarea>
        <div class="controls">
          <button class="primary" id="process">Processar</button>
          <button id="clear">Limpar</button>
          <span class="status" id="status">Pronto.</span>
        </div>
        <div class="opts">
          <div class="opt">
            <input id="optJoin" type="checkbox" checked />
            <div>
              <div><strong>Unir quebras internas</strong></div>
              <div class="hint" style="margin:4px 0 0;">Dentro do mesmo cue, junta linhas com espaço.</div>
            </div>
          </div>
          <div class="opt">
            <input id="optTrim" type="checkbox" checked />
            <div>
              <div><strong>Normalizar espaços</strong></div>
              <div class="hint" style="margin:4px 0 0;">Remove espaços duplicados e aparas nas bordas.</div>
            </div>
          </div>
          <div class="opt">
            <input id="optRemoveTags" type="checkbox" checked />
            <div>
              <div><strong>Remover tags</strong></div>
              <div class="hint" style="margin:4px 0 0;">Remove <span class="kbd">&lt;v&gt;</span>, <span class="kbd">&lt;c&gt;</span> etc.</div>
            </div>
          </div>
          <div class="opt">
            <input id="optDropEmpty" type="checkbox" checked />
            <div>
              <div><strong>Remover linhas vazias</strong></div>
              <div class="hint" style="margin:4px 0 0;">Ignora resultados vazios.</div>
            </div>
          </div>
        </div>
      </div>

      <div>
        <div class="card" style="margin-bottom:14px;">
          <h2>Saída (TXT limpo)</h2>
          <label for="output">Resumo + tabela (texto puro) + transcrição</label>
          <textarea id="output" readonly placeholder="O resultado aparecerá aqui..."></textarea>
          <div class="controls">
            <button class="primary" id="copy">Copiar</button>
            <button id="download">Baixar .txt</button>
            <span class="status" id="outStatus">—</span>
          </div>
        </div>

        <div class="card">
          <h2>Métricas</h2>
          <div class="row cols2">
            <div><div class="pill" id="metaWhen">Data/hora: —</div></div>
            <div><div class="pill" id="metaEnd">Término estimado: —</div></div>
          </div>

          <table aria-label="Tabela de métricas">
            <thead>
              <tr>
                <th style="width:34%;">Participante</th>
                <th style="width:16%;">Tempo</th>
                <th style="width:14%;">% fala</th>
                <th>Distribuição</th>
              </tr>
            </thead>
            <tbody id="statsBody">
              <tr><td colspan="4" style="color: var(--muted);">Nenhum dado ainda.</td></tr>
            </tbody>
          </table>

          <div class="hint" style="margin-top:10px;">
            Se um cue tiver mais de um <span class="kbd">&lt;v Nome&gt;</span>, o tempo do cue é dividido igualmente entre os participantes únicos desse cue.
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    const fileEl = $("file");
    const inputEl = $("input");
    const outputEl = $("output");
    const statusEl = $("status");
    const outStatusEl = $("outStatus");

    const meetingDateEl = $("meetingDate");
    const meetingStartEl = $("meetingStart");
    const meetingTitleEl = $("meetingTitle");
    const meetingNotesEl = $("meetingNotes");

    const pillTitle = $("pillTitle");
    const pillTotal = $("pillTotal");
    const pillPeople = $("pillPeople");

    const metaWhen = $("metaWhen");
    const metaEnd = $("metaEnd");

    const statsBody = $("statsBody");
    const testBadge = $("testBadge");

    const optJoin = $("optJoin");
    const optTrim = $("optTrim");
    const optRemoveTags = $("optRemoveTags");
    const optDropEmpty = $("optDropEmpty");

    function setStatus(msg) { statusEl.textContent = msg; }
    function setOutStatus(msg) { outStatusEl.textContent = msg; }

    function isTimestampLine(line) {
      return /\d{2}:\d{2}:\d{2}(?:\.\d+)?\s*-->\s*\d{2}:\d{2}:\d{2}(?:\.\d+)?/.test(line);
    }

    function stripAllTags(s) {
      return s.replace(/<[^>]+>/g, "");
    }

    function normalizeSpaces(s) {
      return s.replace(/\s+/g, " ").trim();
    }

    function parseTimeToSeconds(ts) {
      const m = ts.match(/^(\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?$/);
      if (!m) return null;
      const hh = Number(m[1]);
      const mm = Number(m[2]);
      const ss = Number(m[3]);
      const ms = m[4] ? Number((m[4] + "000").slice(0, 3)) : 0;
      return (hh * 3600) + (mm * 60) + ss + (ms / 1000);
    }

    function formatDuration(seconds) {
      if (!Number.isFinite(seconds) || seconds < 0) return "—";
      const total = Math.round(seconds);
      const hh = Math.floor(total / 3600);
      const mm = Math.floor((total % 3600) / 60);
      const ss = total % 60;
      const pad2 = (n) => String(n).padStart(2, "0");
      return hh > 0 ? `${hh}:${pad2(mm)}:${pad2(ss)}` : `${mm}:${pad2(ss)}`;
    }

    function inferTitleFromFilename(name) {
      if (!name) return "";
      let base = name.replace(/\.[^.]+$/, "");
      base = base.replace(/[_-]+/g, " ").replace(/\s+/g, " ").trim();
      return base;
    }

    function buildMeetingDateTime() {
      const d = meetingDateEl.value;
      const t = meetingStartEl.value;
      if (!d || !t) return null;
      const dt = new Date(`${d}T${t}:00`);
      return isNaN(dt.getTime()) ? null : dt;
    }

    function formatLocalDateTime(dt) {
      if (!(dt instanceof Date) || isNaN(dt.getTime())) return "—";
      try {
        // Formato conforme o navegador/OS (locale do usuário)
        return new Intl.DateTimeFormat(undefined, { dateStyle: "short", timeStyle: "short" }).format(dt);
      } catch {
        return dt.toLocaleString();
      }
    }

    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function parseVtt(raw) {
      const joinInternal = optJoin.checked;
      const doTrim = optTrim.checked;
      const removeTags = optRemoveTags.checked;
      const dropEmpty = optDropEmpty.checked;

      const text = (raw || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      const blocks = text.split(/\n\s*\n+/g);

      const cleanLines = [];
      const cues = []; // {startS, endS, speakers: [{name, text}]}

      for (const block of blocks) {
        const lines = block.split("\n").map(l => l.trimEnd());
        if (!lines.length) continue;

        if (lines[0].trim() === "WEBVTT") continue;
        const first = lines[0].trim();
        if (/^(NOTE|STYLE|REGION)\b/i.test(first)) continue;

        let i = 0;
        // pula ID do cue se existir
        if (lines[i] && !isTimestampLine(lines[i]) && !/^\d{2}:\d{2}:\d{2}/.test(lines[i]) && !/<v\s+/i.test(lines[i])) {
          i++;
        }

        if (!lines[i] || !isTimestampLine(lines[i])) {
          // fallback textual (sem métricas)
          const payloadFallback = lines.slice(i).filter(l => l.trim().length > 0);
          if (!payloadFallback.length) continue;
          let line = joinInternal ? payloadFallback.join(" ") : payloadFallback.join("\n");
          if (removeTags) line = stripAllTags(line);
          if (doTrim) line = normalizeSpaces(line);
          if (!line && dropEmpty) continue;
          cleanLines.push(line);
          continue;
        }

        const tsLine = lines[i].trim();
        i++;
        const tm = tsLine.match(/(\d{2}:\d{2}:\d{2}(?:\.\d+)?)\s*-->\s*(\d{2}:\d{2}:\d{2}(?:\.\d+)?)/);
        const startS = tm ? parseTimeToSeconds(tm[1]) : null;
        const endS = tm ? parseTimeToSeconds(tm[2]) : null;

        const payload = lines.slice(i).filter(l => l.trim().length > 0);
        if (!payload.length) continue;
        const payloadText = joinInternal ? payload.join(" ") : payload.join("\n");

        // Extrai segmentos <v Nome>...</v>
        const segs = [];
        const re = /<v\s+([^>]+)>([\s\S]*?)<\/v>/gi;
        let match;
        while ((match = re.exec(payloadText)) !== null) {
          const speaker = (match[1] || "").trim();
          let content = match[2] || "";
          if (removeTags) content = stripAllTags(content);
          if (doTrim) content = normalizeSpaces(content);
          if (!content && dropEmpty) continue;
          segs.push({ name: speaker, text: content });
          cleanLines.push(`${speaker}>${content}`);
        }

        if (segs.length) {
          if (Number.isFinite(startS) && Number.isFinite(endS) && endS >= startS) {
            cues.push({ startS, endS, speakers: segs });
          }
          continue;
        }

        // Fallback "Nome: texto"
        let line = payloadText;
        if (removeTags) line = stripAllTags(line);
        if (doTrim) line = normalizeSpaces(line);
        if (!line && dropEmpty) continue;

        const m2 = line.match(/^(.{2,80}?)[：:]\s*(.+)$/);
        if (m2) {
          const speaker = doTrim ? normalizeSpaces(m2[1]) : m2[1].trim();
          const content = doTrim ? normalizeSpaces(m2[2]) : m2[2].trim();
          if (!content && dropEmpty) continue;
          cleanLines.push(`${speaker}>${content}`);
          if (Number.isFinite(startS) && Number.isFinite(endS) && endS >= startS) {
            cues.push({ startS, endS, speakers: [{ name: speaker, text: content }] });
          }
        } else {
          cleanLines.push(line);
        }
      }

      return { cleanText: cleanLines.join("\n"), cues };
    }

    function computeStats(cues) {
      let minS = Infinity;
      let maxE = -Infinity;
      const personSeconds = new Map();
      const presence = new Set();

      for (const cue of cues) {
        if (!Number.isFinite(cue.startS) || !Number.isFinite(cue.endS)) continue;
        minS = Math.min(minS, cue.startS);
        maxE = Math.max(maxE, cue.endS);

        const dur = Math.max(0, cue.endS - cue.startS);
        const speakers = cue.speakers || [];
        if (!speakers.length) continue;

        const uniqueNames = Array.from(new Set(speakers.map(s => s.name).filter(Boolean)));
        uniqueNames.forEach(n => presence.add(n));

        // Divide igualmente o tempo do cue entre participantes únicos do cue.
        const share = uniqueNames.length ? dur / uniqueNames.length : 0;
        for (const name of uniqueNames) {
          personSeconds.set(name, (personSeconds.get(name) || 0) + share);
        }
      }

      const totalMeeting = (minS !== Infinity && maxE !== -Infinity) ? Math.max(0, maxE - minS) : 0;
      let totalSpeech = 0;
      for (const v of personSeconds.values()) totalSpeech += v;

      const rows = Array.from(personSeconds.entries())
        .map(([name, seconds]) => ({ name, seconds }))
        .sort((a, b) => b.seconds - a.seconds);

      for (const r of rows) r.pct = totalSpeech > 0 ? (r.seconds / totalSpeech) * 100 : 0;

      return {
        totalMeeting,
        totalSpeech,
        presence: Array.from(presence).sort((a, b) => a.localeCompare(b, undefined)),
        rows,
      };
    }

    function getMeetingTitleParts() {
      const typed = (meetingTitleEl.value || "").trim();
      const inferred = (meetingTitleEl.getAttribute("data-inferred") || "").trim();
      const title = typed || inferred || "(sem título)";
      const notes = (meetingNotesEl.value || "").trim();
      return { title, notes };
    }

    function updateTitlePill() {
      const { title, notes } = getMeetingTitleParts();
      pillTitle.textContent = notes ? `Título: ${title} • ${notes}` : `Título: ${title}`;
    }

    function renderStats(stats) {
      pillTotal.textContent = `Duração total: ${formatDuration(stats.totalMeeting)}`;
      pillPeople.textContent = `Participantes: ${stats.presence.length}`;

      const startDT = buildMeetingDateTime();
      if (startDT) {
        metaWhen.textContent = `Data/hora: ${formatLocalDateTime(startDT)}`;
        const endDT = new Date(startDT.getTime() + Math.round(stats.totalMeeting * 1000));
        metaEnd.textContent = `Término estimado: ${formatLocalDateTime(endDT)}`;
      } else {
        metaWhen.textContent = `Data/hora: —`;
        metaEnd.textContent = `Término estimado: —`;
      }

      // Evitar injetar HTML do arquivo: só usamos innerHTML com strings controladas.
      statsBody.innerHTML = "";
      if (!stats.rows.length) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="4" style="color: var(--muted);">Nenhum dado de fala encontrado (verifique se o VTT contém timestamps + &lt;v Nome&gt;...&lt;/v&gt;).</td>`;
        statsBody.appendChild(tr);
        return;
      }

      const maxPct = Math.max(...stats.rows.map(r => r.pct));

      for (const r of stats.rows) {
        const tr = document.createElement("tr");
        const pctStr = `${r.pct.toFixed(1)}%`;
        const w = maxPct > 0 ? (r.pct / maxPct) * 100 : 0;
        // name é escapado; pctStr e w são números/formatos controlados
        tr.innerHTML = `
          <td><strong>${escapeHtml(r.name)}</strong></td>
          <td>${formatDuration(r.seconds)}</td>
          <td>${pctStr}</td>
          <td><div class="bar" title="${pctStr}"><div style="width:${w.toFixed(1)}%"></div></div></td>
        `;
        statsBody.appendChild(tr);
      }
    }

    function padRight(s, n) {
      s = String(s);
      return s.length >= n ? s : s + " ".repeat(n - s.length);
    }

    function buildPlainTextTable(stats) {
      const rows = stats.rows || [];
      const header1 = "Participante";
      const header2 = "Tempo";
      const header3 = "% fala";

      const nameW = Math.min(40, Math.max(header1.length, ...rows.map(r => String(r.name).length)));
      const timeW = Math.max(header2.length, ...rows.map(r => formatDuration(r.seconds).length));
      const pctW = Math.max(header3.length, ...rows.map(r => `${r.pct.toFixed(1)}%`.length));

      const lines = [];
      lines.push(`${padRight(header1, nameW)}  ${padRight(header2, timeW)}  ${padRight(header3, pctW)}`);
      lines.push(`${"-".repeat(nameW)}  ${"-".repeat(timeW)}  ${"-".repeat(pctW)}`);

      for (const r of rows) {
        const pct = `${r.pct.toFixed(1)}%`;
        lines.push(`${padRight(r.name, nameW)}  ${padRight(formatDuration(r.seconds), timeW)}  ${padRight(pct, pctW)}`);
      }
      return lines.join("\n");
    }

    function buildPlainTextSummary(stats) {
      const { title, notes } = getMeetingTitleParts();
      const startDT = buildMeetingDateTime();
      const startStr = startDT ? formatLocalDateTime(startDT) : "—";

      const participants = (stats.presence || []).join(", ") || "—";
      const totalMeetingStr = formatDuration(stats.totalMeeting);
      const totalSpeechStr = formatDuration(stats.totalSpeech);

      const lines = [];
      lines.push(`Título: ${title}${notes ? ` (${notes})` : ""}`);
      lines.push(`Início: ${startStr}`);
      lines.push(`Participantes (${(stats.presence || []).length}): ${participants}`);
      lines.push(`Tempo total da reunião: ${totalMeetingStr}`);
      lines.push(`Tempo total de fala (estimado): ${totalSpeechStr}`);
      lines.push("");
      lines.push("Fala por participante:");
      lines.push(buildPlainTextTable(stats));
      return lines.join("\n");
    }

    function buildFinalOutput(transcriptCleanText, stats) {
      const summary = buildPlainTextSummary(stats);
      const transcript = (transcriptCleanText || "").trim();
      return transcript ? `${summary}\n\nTranscrição:\n${transcript}\n` : `${summary}\n`;
    }

    async function readFileAsText(file) {
      return await file.text();
    }

    function applyInferredTitle(filename) {
      const inferred = inferTitleFromFilename(filename);
      meetingTitleEl.setAttribute("data-inferred", inferred);
      updateTitlePill();
    }

    // --- Eventos ---
    fileEl.addEventListener("change", async () => {
      const f = fileEl.files && fileEl.files[0];
      if (!f) return;
      try {
        setStatus(`Lendo: ${f.name}...`);
        const content = await readFileAsText(f);
        inputEl.value = content;
        applyInferredTitle(f.name);
        setStatus(`Arquivo carregado: ${f.name}`);
      } catch (e) {
        console.error(e);
        setStatus("Falha ao ler o arquivo.");
      }
    });

    meetingTitleEl.addEventListener("input", updateTitlePill);
    meetingNotesEl.addEventListener("input", updateTitlePill);

    let lastStats = { totalMeeting: 0, totalSpeech: 0, presence: [], rows: [] };

    meetingDateEl.addEventListener("change", () => renderStats(lastStats));
    meetingStartEl.addEventListener("change", () => renderStats(lastStats));

    $("process").addEventListener("click", () => {
      const raw = inputEl.value || "";
      if (!raw.trim()) {
        setStatus("Nenhuma entrada para processar.");
        outputEl.value = "";
        setOutStatus("—");
        lastStats = { totalMeeting: 0, totalSpeech: 0, presence: [], rows: [] };
        renderStats(lastStats);
        updateTitlePill();
        return;
      }
      try {
        const parsed = parseVtt(raw);
        lastStats = computeStats(parsed.cues);
        renderStats(lastStats);
        updateTitlePill();

        outputEl.value = buildFinalOutput(parsed.cleanText, lastStats);

        const count = parsed.cleanText ? parsed.cleanText.split("\n").filter(Boolean).length : 0;
        setStatus("Processado.");
        setOutStatus(`${count} linha(s) na transcrição`);
      } catch (e) {
        console.error(e);
        setStatus("Erro ao processar.");
      }
    });

    $("clear").addEventListener("click", () => {
      inputEl.value = "";
      outputEl.value = "";
      fileEl.value = "";
      meetingTitleEl.value = "";
      meetingTitleEl.setAttribute("data-inferred", "");
      meetingNotesEl.value = "";
      updateTitlePill();
      setStatus("Pronto.");
      setOutStatus("—");
      pillTotal.textContent = "Duração total: —";
      pillPeople.textContent = "Participantes: —";
      lastStats = { totalMeeting: 0, totalSpeech: 0, presence: [], rows: [] };
      renderStats(lastStats);
    });

    $("copy").addEventListener("click", async () => {
      try {
        const text = outputEl.value || "";
        if (!text.trim()) {
          setOutStatus("Nada para copiar");
          return;
        }
        await navigator.clipboard.writeText(text);
        setOutStatus("Copiado");
      } catch {
        outputEl.focus();
        outputEl.select();
        const ok = document.execCommand("copy");
        setOutStatus(ok ? "Copiado" : "Não foi possível copiar");
      }
    });

    $("download").addEventListener("click", () => {
      const text = outputEl.value || "";
      if (!text.trim()) {
        setOutStatus("Nada para baixar");
        return;
      }
      const inferred = meetingTitleEl.getAttribute("data-inferred") || "";
      const title = (meetingTitleEl.value || inferred || "transcricao").trim();
      const safeTitle = title.replace(/[^\w\d\-\s]+/g, "").trim().replace(/\s+/g, "-").toLowerCase();
      const stamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, "-");
      const filename = `${safeTitle || "transcricao"}-limpa-${stamp}.txt`;

      const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      setOutStatus("Download iniciado");
    });

    // --- Testes (sem libs) ---
    function assert(cond, msg) {
      if (!cond) throw new Error(msg || "assert failed");
    }

    function runTests() {
      const vttSample = `WEBVTT\n\n00:00:00.000 --> 00:00:02.000\n<v Roberta Fonseca>Não.</v>\n\n00:00:02.000 --> 00:00:06.000\n<v Antonio Schneider>Olá</v>\n\n00:00:06.000 --> 00:00:10.000\n<v Roberta Fonseca>Ok</v><v Antonio Schneider>Ok também</v>\n`;

      // parseTimeToSeconds
      assert(parseTimeToSeconds("00:00:01.500") === 1.5, "parseTimeToSeconds ms");
      assert(parseTimeToSeconds("01:00:00") === 3600, "parseTimeToSeconds hh");

      // parseVtt output
      const parsed = parseVtt(vttSample);
      assert(parsed.cleanText.includes("Roberta Fonseca>Não."), "cleanText includes speaker line");

      // stats
      const stats = computeStats(parsed.cues);
      assert(stats.presence.length === 2, "presence length");
      assert(Math.round(stats.totalMeeting) === 10, "totalMeeting 10s");

      // cue with 2 speakers split equally: last cue 4s => 2s each
      const a = stats.rows.find(r => r.name === "Antonio Schneider");
      const r = stats.rows.find(r => r.name === "Roberta Fonseca");
      assert(a && r, "rows have both");
      // Antonio: 4s (cue2) + 2s (shared cue3) = 6s
      // Roberta: 2s (cue1) + 2s (shared cue3) = 4s
      assert(Math.round(a.seconds) === 6, "Antonio seconds");
      assert(Math.round(r.seconds) === 4, "Roberta seconds");

      // plain text summary/table
      const summary = buildPlainTextSummary(stats);
      assert(summary.includes("Fala por participante:"), "summary includes table header");
      assert(summary.includes("Participante"), "table has Participante header");

      return true;
    }

    function setTestBadge(ok, err) {
      if (ok) {
        testBadge.textContent = "tests: ok";
      } else {
        testBadge.textContent = "tests: falharam";
        testBadge.title = err ? String(err) : "";
      }
    }

    // Inicial
    updateTitlePill();
    renderStats(lastStats);
    try {
      runTests();
      setTestBadge(true);
    } catch (e) {
      console.error("Test failure:", e);
      setTestBadge(false, e);
    }
  </script>
</body>
</html>
